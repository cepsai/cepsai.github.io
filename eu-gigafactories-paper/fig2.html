<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://www.paballand.com/js/d3plus-plot.v0.9.full.min.js"></script>
<style>
:root{--bg:#ffffff;--axis:#cfcfcf;--grid:#e9e9e9;--text:#6b6b6b;--text-strong:#333333;--muted:#9aa0a6;}
html,body{height:100%;}
body{margin:0;overflow:hidden;background:var(--bg);font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;color:var(--text);}
.viz-grid{display:grid;grid-template-rows:1fr auto;grid-template-columns:1fr;height:100vh;width:100vw;gap:0;padding:0;}
#container1{grid-row:1;grid-column:1;display:flex;min-height:0;min-width:0;}
#container2{grid-row:2;grid-column:1;display:flex;align-items:center;justify-content:center;padding:10px 14px;border-top:1px solid rgba(0,0,0,0.08);background:#fff;}
#chart{flex:1 1 auto;min-width:0;min-height:0;}
#chart svg{background:var(--bg);}
.custom-legend{display:flex;flex-wrap:wrap;align-items:center;justify-content:center;gap:clamp(6px,1.5vw,14px);background:rgba(255,255,255,0.9);padding:clamp(6px,1.2vh,10px) clamp(10px,2vw,16px);border-radius:clamp(6px,1.2vw,12px);box-shadow:0 2px 8px rgba(0,0,0,0.1);max-width:100%;}
.legend-item{display:flex;align-items:center;gap:6px;cursor:pointer;transition:opacity .2s ease;font-weight:600;color:#333;font-size:clamp(11px,1.4vw,14px);}
.legend-item.dim{opacity:.35;}
.legend-item:focus-visible{outline:2px solid rgba(0,0,0,0.45);outline-offset:2px;}
.legend-square{width:clamp(10px,1.2vw,14px);height:clamp(10px,1.2vw,14px);border-radius:4px;box-shadow:0 0 0 1px rgba(0,0,0,0.15) inset;}
.d3plus-Axis path.domain{stroke:var(--axis)!important;}
.d3plus-Axis .tick line{stroke:var(--grid)!important;}
.d3plus-Axis .tick text{fill:var(--text)!important;font-size:12px!important;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif!important;}
.d3plus-Axis .title{fill:var(--text-strong)!important;font-size:14px!important;font-weight:600!important;}
.d3plus-tooltip{background:#ffffff!important;border:1px solid #e5e5e5!important;border-radius:8px!important;box-shadow:0 10px 24px rgba(0,0,0,.1)!important;color:var(--text-strong)!important;}
.d3plus-tooltip-title{font-weight:700!important;font-size:13px!important;color:var(--text-strong)!important;}
.d3plus-tooltip-body{font-size:12px!important;color:var(--text)!important;}
.custom-label{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:10px;opacity:1;font-weight:400;pointer-events:none;transform-origin:center;color:#000;}
.custom-label.collision{opacity:.35;}
.custom-label.hover{opacity:1!important;font-size:16px!important;font-weight:700!important;}
.custom-label, text.custom-label{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif!important;font-size:10px!important;fill:currentColor!important;stroke:none!important;font-weight:400!important;}
tspan{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:12px;font-style:normal;}
</style>
</head>
<body>
<div class="viz-grid">
  <div id="container1"><div id="chart"></div></div>
  <div id="container2"><div id="legend" class="custom-legend"></div></div>
</div>
<script>
const OVERLAP_CLUSTER_REMOVE_COUNT=3;
const LABEL_BBOX_PAD=2;
const NO_MATCH_LABEL="No match";
const NO_MATCH_COLOR="#9aa0a6";
const GROUP_COLOR_MAP={"Country match":"#F3C64C","NUTS-2 match":"#207164","Partner country":"#7470B3","No match":NO_MATCH_COLOR};
let customLabels=[];
let isUpdating=false;
let hoveringElements=new Set();
let activeLegendKey=null;
let colorScale=null;
let legendValues=[];
function median(v){
  if(!v.length)throw new Error("empty");
  v=[...v].sort((a,b)=>a-b);
  const h=Math.floor(v.length/2);
  return v.length%2?v[h]:(v[h-1]+v[h])/2;
}
function truncateText(text,maxLength=18){
  if(text.length<=maxLength){
    return text;
  }
  return text.substring(0,maxLength)+"...";
}
function rectanglesOverlap(rect1,rect2){
  return !(rect1.x+rect1.width<rect2.x||rect2.x+rect2.width<rect1.x||rect1.y+rect1.height<rect2.y||rect2.y+rect2.height<rect1.y);
}
function rectIntersectionArea(a,b){
  const x=Math.max(a.x,b.x);
  const y=Math.max(a.y,b.y);
  const w=Math.min(a.x+a.width,b.x+b.width)-x;
  const h=Math.min(a.y+a.height,b.y+b.height)-y;
  if(w<=0||h<=0){
    return 0;
  }
  return w*h;
}
function expandRect(rect,pad=LABEL_BBOX_PAD){
  return {x:rect.x-pad,y:rect.y-pad,width:rect.width+pad*2,height:rect.height+pad*2};
}
function getPositionOptions(centerX,centerY,radius,padding=5){
  const d=radius+padding;
  const yb=centerY+3;
  return [
    {name:"right",x:centerX+d,y:yb,anchor:"start"},
    {name:"left",x:centerX-d,y:yb,anchor:"end"},
    {name:"below",x:centerX,y:centerY+d+10,anchor:"middle"},
    {name:"above",x:centerX,y:centerY-d,anchor:"middle"},
    {name:"right-top",x:centerX+d,y:centerY-d*0.6,anchor:"start"},
    {name:"right-bottom",x:centerX+d,y:centerY+d*0.6,anchor:"start"},
    {name:"left-top",x:centerX-d,y:centerY-d*0.6,anchor:"end"},
    {name:"left-bottom",x:centerX-d,y:centerY+d*0.6,anchor:"end"}
  ];
}
function hasCollisionWithCircles(textElement,allCircles){
  try{
    const textBBox=textElement.getBBox();
    for(const circleData of allCircles){
      const r=parseFloat(circleData.circle.getAttribute('r'))||7.5;
      const circleBBox={x:circleData.coords.x-r,y:circleData.coords.y-r,width:r*2,height:r*2};
      if(rectanglesOverlap(textBBox,circleBBox)){
        return true;
      }
    }
    return false;
  }catch(e){
    return false;
  }
}
function bestPositionSmart(textElement,centerX,centerY,radius,allCircles,fullText,placedBoxes){
  const positions=getPositionOptions(centerX,centerY,radius);
  function scoreFor(text){
    textElement.textContent=text;
    let best={pos:null,text:text,score:Infinity,circleHit:false,bbox:null};
    for(const pos of positions){
      textElement.setAttribute('x',pos.x);
      textElement.setAttribute('y',pos.y);
      textElement.setAttribute('text-anchor',pos.anchor);
      let bbox;
      try{
        bbox=expandRect(textElement.getBBox(),LABEL_BBOX_PAD);
      }catch(e){
        continue;
      }
      let circleHit=false;
      for(const c of allCircles){
        const r=parseFloat(c.circle.getAttribute('r'))||7.5;
        const circleBBox={x:c.coords.x-r,y:c.coords.y-r,width:r*2,height:r*2};
        if(rectanglesOverlap(bbox,circleBBox)){
          circleHit=true;
          break;
        }
      }
      let overlapArea=0;
      for(const pb of placedBoxes){
        overlapArea+=rectIntersectionArea(bbox,pb);
      }
      const score=(circleHit?1e9:0)+overlapArea;
      if(score<best.score){
        best={pos:pos,text:text,score:score,circleHit:circleHit,bbox:bbox};
      }
    }
    return best;
  }
  const full=scoreFor(fullText);
  if(!full.circleHit&&full.score===0){
    return {...full,hasCollision:false};
  }
  const truncated=scoreFor(truncateText(fullText,18));
  if(!truncated.circleHit&&truncated.score===0){
    return {...truncated,hasCollision:true};
  }
  if(truncated.score<=full.score){
    return {...truncated,hasCollision:true};
  }
  return {...full,hasCollision:full.circleHit||full.score>0};
}
function findMatchingDataPoint(circle){
  const bound=circle.__data__||d3.select(circle).datum();
  if(bound)return bound;
  return null;
}
function normalizeGroup(v){
  const t=String(v||"").trim();
  const l=t.toLowerCase();
  if(!t||l==="no match"||l==="nomatch"||l==="none")return NO_MATCH_LABEL;
  if(l==="partner country"||l==="partner-country"||l==="partner")return "Partner country";
  if(l==="country match"||l==="country-match"||l==="country")return "Country match";
  if(l==="nuts-2 match"||l==="nuts2 match"||l==="nuts2-match"||l==="nuts2"||l==="nuts-2")return "NUTS-2 match";
  return t;
}
function loadCSV(path){
  return d3.csv(path).then(raw=>{
    const cols=raw.columns||Object.keys(raw[0]||{});
    const regionKey=cols.find(c=>String(c).toLowerCase().includes('region'))||'Region';
    const aiKey=cols.find(c=>String(c).toLowerCase().startsWith('ai index'))||cols[1];
    const computeKey=cols.find(c=>String(c).toLowerCase().startsWith('compute index'))||cols[2];
    const blankKey=cols.find(c=>String(c).trim()==='');
    const guessKey=cols.find(c=>/group|cluster|class|category|segment/i.test(String(c)))||blankKey||'group';
    const data=raw.map(r=>{
      const ai=+r[aiKey];
      const comp=+r[computeKey];
      const groupVal=normalizeGroup(r[guessKey]);
      return {id:r[regionKey],ai:ai,compute:comp,x:ai,y:comp,group:groupVal,annotate:r['annotate_geo']==='True'||r['annotate_geo']===true||r['annotate_geo']==='true',value:1};
    })
    .filter(d=>d.id&&Number.isFinite(d.x)&&Number.isFinite(d.y)&&!(d.x===0&&d.y===0)&&!(d.x<3&&d.y<1));
    const setOrder=["Country match","NUTS-2 match","Partner country",NO_MATCH_LABEL];
    const present=Array.from(new Set(data.map(d=>d.group)));
    legendValues=setOrder.filter(v=>present.includes(v)).concat(present.filter(v=>!setOrder.includes(v)));
    const domain=legendValues.filter(v=>v!==NO_MATCH_LABEL);
    const range=domain.map(v=>GROUP_COLOR_MAP[v]||"#207164");
    colorScale=d3.scaleOrdinal().domain(domain).range(range);
    data.forEach(d=>{d.color=d.group===NO_MATCH_LABEL?NO_MATCH_COLOR:(GROUP_COLOR_MAP[d.group]||colorScale(d.group));});
    return {data,aiKey,computeKey};
  });
}
function drawPlot(loaded){
  const data=loaded.data;
  const aiKey=loaded.aiKey;
  const computeKey=loaded.computeKey;
  const xVals=data.map(d=>d.x).filter(Number.isFinite);
  const yVals=data.map(d=>d.y).filter(Number.isFinite);
  const xMin=Math.min(...xVals);
  const xMax=Math.max(...xVals);
  const yMin=Math.min(...yVals);
  const yMax=Math.max(...yVals);
  const xPad=(xMax-xMin||1)*0.1;
  const yPad=(yMax-yMin||1)*0.1;
  const xDomain=[Math.max(0,xMin-xPad),xMax+xPad];
  const minY=yMin-yPad;
  const maxY=yMax+yPad;
  new d3plus.Plot()
    .select('#chart')
    .data(data)
    .annotations([{data:[{id:'Trend',x:median(xVals),y:minY},{id:'Trend',x:median(xVals),y:maxY},{id:'Baseline',x:xDomain[0],y:median(yVals)},{id:'Baseline',x:xDomain[1],y:median(yVals)}],shape:'Line',stroke:'#d9d9d9',strokeDasharray:'4 3',strokeWidth:1}])
    .groupBy('id')
    .tooltipConfig({
      body:d=>`<table class='tooltip-table'>
        <tr><td class='title'>AI ecosystem index:</td><td class='data'>${d.ai}</td></tr>
        <tr><td class='title'>Compute Index:</td><td class='data'>${d.compute}</td></tr>
        <tr><td class='title'>Region:</td><td class='data'>${d.id}</td></tr>
        <tr><td class='title'>Group:</td><td class='data'>${d.group}</td></tr>
      </table>`,
      title:d=>d.id
    })
    .size('value')
    .sizeMin(12)
    .sizeMax(12)
    .color('color')
    .label('')
    .shapeConfig({
      fillOpacity:.65,
      stroke:'#ffffff',
      strokeWidth:1.5,
      Circle:{labelConfig:{fontSize:0}}
    })
    .yConfig({
      title:computeKey,
      titleConfig:{fontSize:()=>14,fontWeight:600,fill:'#333'},
      gridConfig:{stroke:'#e9e9e9',strokeWidth:1},
      shapeConfig:{labelConfig:{fontSize:()=>12}}
    })
    .xDomain(xDomain)
    .xConfig({
      title:aiKey,
      titleConfig:{fontSize:()=>14,fontWeight:600,fill:'#333'},
      gridConfig:{stroke:'#e9e9e9',strokeWidth:1},
      shapeConfig:{labelConfig:{fontSize:()=>12}}
    })
    .legend(false)
    .downloadButton(false)
    .render();
  setTimeout(()=>{initializeCustomLabels();startPositionUpdater();buildLegend();applyLegendFilter();},500);
}
function initializeCustomLabels(){
  const svg=document.querySelector('#chart svg');
  if(!svg){
    setTimeout(initializeCustomLabels,100);
    return;
  }
  const circles=svg.querySelectorAll('circle');
  customLabels=[];
  hoveringElements=new Set();
  circles.forEach(circle=>{
    const matchingData=findMatchingDataPoint(circle);
    if(matchingData){
      const fullText=matchingData.id;
      const text=document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('class','custom-label');
      text.setAttribute('data-id',matchingData.id);
      text.setAttribute('text-anchor','start');
      text.setAttribute('font-family','Helvetica Neue, Arial, sans-serif');
      text.setAttribute('font-size','10');
      text.style.color=matchingData.color;
      text.textContent=fullText;
      svg.appendChild(text);
      customLabels.push({circle:circle,text:text,data:matchingData,fullText:fullText,defaultText:fullText,savedPosition:null,hiddenByCluster:false,wasHiddenBeforeHover:false,dimByLegend:false});
      circle.addEventListener('mouseenter',()=>{
        hoveringElements.add(text);
        const labelData=customLabels.find(l=>l.circle===circle);
        if(labelData){
          labelData.savedPosition={x:text.getAttribute('x'),y:text.getAttribute('y'),anchor:text.getAttribute('text-anchor'),content:text.textContent};
          labelData.wasHiddenBeforeHover=labelData.hiddenByCluster||labelData.dimByLegend;
          labelData.hiddenByCluster=false;
          labelData.dimByLegend=false;
        }
        text.classList.add('hover');
        text.textContent=fullText;
        text.setAttribute('opacity','1');
        text.style.display='';
        text.style.pointerEvents='auto';
      });
      circle.addEventListener('mouseleave',()=>{
        hoveringElements.delete(text);
        text.classList.remove('hover');
        const labelData=customLabels.find(l=>l.circle===circle);
        if(labelData&&labelData.savedPosition){
          text.setAttribute('x',labelData.savedPosition.x);
          text.setAttribute('y',labelData.savedPosition.y);
          text.setAttribute('text-anchor',labelData.savedPosition.anchor);
          text.textContent=labelData.savedPosition.content;
          labelData.dimByLegend=labelData.wasHiddenBeforeHover;
          labelData.hiddenByCluster=false;
          labelData.wasHiddenBeforeHover=false;
        }
        applyLegendFilter();
      });
    }
  });
  updateLabelPositions();
}
function updateLabelPositions(){
  if(isUpdating)return;
  isUpdating=true;
  const svg=document.querySelector('#chart svg');
  if(!svg){
    isUpdating=false;
    return;
  }
  const circlePositions=[];
  customLabels.forEach(({circle,text})=>{
    if(circle&&text){
      const bbox=circle.getBoundingClientRect();
      const svgRect=svg.getBoundingClientRect();
      const svgPoint=svg.createSVGPoint();
      svgPoint.x=bbox.left+bbox.width/2-svgRect.left;
      svgPoint.y=bbox.top+bbox.height/2-svgRect.top;
      const screenCTM=svg.getScreenCTM();
      if(screenCTM){
        const svgCoords=svgPoint.matrixTransform(screenCTM.inverse());
        circlePositions.push({circle:circle,coords:svgCoords});
      }
    }
  });
  const labels=customLabels.slice();
  labels.sort((a,b)=>{
    const ha=hoveringElements.has(a.text)?-1:0;
    const hb=hoveringElements.has(b.text)?-1:0;
    if(ha!==hb)return ha-hb;
    const ax=circlePositions.find(cp=>cp.circle===a.circle)?.coords.x||0;
    const bx=circlePositions.find(cp=>cp.circle===b.circle)?.coords.x||0;
    return ax-bx;
  });
  const placedBoxes=[];
  labels.forEach(labelData=>{
    const {circle,text,fullText}=labelData;
    if(!circle||!text){
      return;
    }
    if(hoveringElements.has(text)){
      try{
        placedBoxes.push(expandRect(text.getBBox(),LABEL_BBOX_PAD));
      }catch(e){}
      return;
    }
    const circleData=circlePositions.find(cp=>cp.circle===circle);
    if(!circleData){
      return;
    }
    const r=parseFloat(circle.getAttribute('r'))||7.5;
    const best=bestPositionSmart(text,circleData.coords.x,circleData.coords.y,r,circlePositions,fullText,placedBoxes);
    text.setAttribute('x',best.pos.x);
    text.setAttribute('y',best.pos.y);
    text.setAttribute('text-anchor',best.pos.anchor);
    text.textContent=best.text;
    labelData.defaultText=best.text;
    if(best.hasCollision){
      text.classList.add('collision');
      if(!labelData.hiddenByCluster&&!labelData.dimByLegend)text.setAttribute('opacity','0.35');
    }else{
      text.classList.remove('collision');
      if(!labelData.hiddenByCluster&&!labelData.dimByLegend)text.setAttribute('opacity','1');
    }
    try{
      placedBoxes.push(expandRect(text.getBBox(),LABEL_BBOX_PAD));
    }catch(e){}
    if(labelData.hiddenByCluster||labelData.dimByLegend){
      text.style.display='none';
      text.style.pointerEvents='none';
    }else{
      text.style.display='';
      text.style.pointerEvents='auto';
    }
  });
  hideClustersOfThreeOrMore();
  isUpdating=false;
}
function hideClustersOfThreeOrMore(){
  const labels=customLabels.filter(ld=>ld.text&&ld.circle&&!ld.dimByLegend);
  const n=labels.length;
  const boxes=new Array(n);
  for(let i=0;i<n;i++){
    try{
      boxes[i]=expandRect(labels[i].text.getBBox(),LABEL_BBOX_PAD);
    }catch(e){
      boxes[i]=null;
    }
  }
  const adj=Array.from({length:n},()=>[]);
  for(let i=0;i<n;i++){
    if(!boxes[i])continue;
    for(let j=i+1;j<n;j++){
      if(!boxes[j])continue;
      if(rectanglesOverlap(boxes[i],boxes[j])){
        adj[i].push(j);
        adj[j].push(i);
      }
    }
  }
  const visited=new Array(n).fill(false);
  for(let i=0;i<n;i++){
    if(visited[i])continue;
    const stack=[i];
    const comp=[];
    while(stack.length){
      const v=stack.pop();
      if(visited[v])continue;
      visited[v]=true;
      comp.push(v);
      for(const u of adj[v]){
        if(!visited[u])stack.push(u);
      }
    }
    if(comp.length>=OVERLAP_CLUSTER_REMOVE_COUNT){
      for(const idx of comp){
        const ld=labels[idx];
        if(hoveringElements.has(ld.text))continue;
        ld.hiddenByCluster=true;
        ld.text.style.display='none';
        ld.text.style.pointerEvents='none';
      }
    }else{
      for(const idx of comp){
        const ld=labels[idx];
        if(hoveringElements.has(ld.text))continue;
        ld.hiddenByCluster=false;
        ld.text.style.display='';
        if(ld.text.classList.contains('collision')){
          ld.text.setAttribute('opacity','0.35');
        }else{
          ld.text.setAttribute('opacity','1');
        }
        ld.text.style.pointerEvents='auto';
      }
    }
  }
}
function startPositionUpdater(){
  function updateLoop(){
    updateLabelPositions();
    requestAnimationFrame(updateLoop);
  }
  updateLoop();
  const chartElement=document.getElementById('chart');
  if(chartElement){
    chartElement.addEventListener('wheel',updateLabelPositions,{passive:true});
    chartElement.addEventListener('mousedown',updateLabelPositions);
    chartElement.addEventListener('mousemove',updateLabelPositions);
    chartElement.addEventListener('mouseup',updateLabelPositions);
  }
}
function buildLegend(){
  const legend=document.getElementById('legend');
  legend.innerHTML='';
  legendValues.forEach(val=>{
    const item=document.createElement('div');
    item.className='legend-item';
    item.setAttribute('role','button');
    item.setAttribute('tabindex','0');
    item.setAttribute('aria-pressed','false');
    const square=document.createElement('div');
    square.className='legend-square';
    square.style.background=(val===NO_MATCH_LABEL)?NO_MATCH_COLOR:(GROUP_COLOR_MAP[val]||colorScale(val));
    const label=document.createElement('span');
    label.textContent=String(val);
    item.appendChild(square);
    item.appendChild(label);
    item.addEventListener('click',()=>toggleLegend(val,item));
    item.addEventListener('keydown',(e)=>{if(e.key==='Enter'||e.key===' '){e.preventDefault();toggleLegend(val,item);}});
    legend.appendChild(item);
  });
  updateLegendStyles();
}
function toggleLegend(value,el){
  activeLegendKey=activeLegendKey===value?null:value;
  updateLegendStyles();
  applyLegendFilter();
}
function updateLegendStyles(){
  const items=document.querySelectorAll('#legend .legend-item');
  items.forEach((it,idx)=>{
    const v=legendValues[idx];
    const dim=activeLegendKey&&v!==activeLegendKey;
    it.classList.toggle('dim',dim);
    it.setAttribute('aria-pressed',activeLegendKey===v?'true':'false');
  });
}
function applyLegendFilter(){
  const svg=document.querySelector('#chart svg');
  if(!svg)return;
  const circles=svg.querySelectorAll('circle');
  circles.forEach(c=>{
    const d=findMatchingDataPoint(c);
    if(!d)return;
    const dim=activeLegendKey&&d.group!==activeLegendKey;
    c.style.opacity=dim?0.25:1;
  });
  customLabels.forEach(ld=>{
    const dim=activeLegendKey&&ld.data.group!==activeLegendKey;
    ld.dimByLegend=dim&&!hoveringElements.has(ld.text);
  });
  updateLabelPositions();
}
loadCSV('fig2.csv').then(drawPlot);
</script>
</body>
</html>