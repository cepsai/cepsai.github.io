<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <script src="https://www.paballand.com/js/d3plus-plot.v0.9.full.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, Helvetica, sans-serif;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #chart {
            flex: 1 1 auto;
        }

        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            padding: 4px 0;
            flex: 0 0 auto;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 2px 8px;
            font-size: 11px;
            white-space: nowrap;
        }

        .legend-item.interactive {
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .legend-item.inactive {
            opacity: 0.4;
        }

        .box {
            width: 14px;
            height: 14px;
            margin-right: 10px;
            border: none;
        }

        .pos {
            background: #2d7c2d;
        }

        .neg {
            background: #8B1A0F;
        }

        .tooltip-table {
            width: 100%;
        }

        .tooltip-table .data {
            text-align: right;
        }

        .tooltip-footer {
            opacity: .5;
        }

        tspan {
            font-family: "Helvetica", "Arial", sans-serif;
            font-size: 100px;
            font-style: oblique;
        }

        .custom-label {
            font-family: Arial, Helvetica, sans-serif;
            font-size: 10px;
            fill: #000;
            opacity: 1;
            font-weight: normal;
            transition: opacity 0.4s ease, font-size 0.4s ease, font-weight 0.4s ease;
            pointer-events: none;
            transform-origin: center;
        }

        .custom-label.collision {
            opacity: 0.3;
        }

        .custom-label.hover {
            opacity: 1 !important;
            font-size: 13px !important;
            font-weight: bold !important;
        }

        .custom-label,
        text.custom-label {
            font-family: Arial, Helvetica, sans-serif !important;
            font-size: 10px;
            fill: #000 !important;
            stroke: none !important;
            font-weight: normal !important;
        }

        .connector-line {
            stroke: #000;
            stroke-width: 1px;
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="chart"></div>
        <div class="legend"></div>
    </div>
    <script>
        function median(v) {
            if (!v.length) throw new Error("empty");
            v = [...v].sort((a, b) => a - b);
            const h = Math.floor(v.length / 2);
            return v.length % 2 ? v[h] : (v[h - 1] + v[h]) / 2;
        }

        function truncateText(text, maxLength = 35) {
            if (text.length <= maxLength) {
                return text;
            }
            return text.substring(0, maxLength) + "...";
        }

        function rectanglesOverlap(rect1, rect2) {
            return !(rect1.x + rect1.width < rect2.x ||
                rect2.x + rect2.width < rect1.x ||
                rect1.y + rect1.height < rect2.y ||
                rect2.y + rect2.height < rect1.y);
        }

        function getPositionOptions(centerX, centerY, radius, padding = 8) {
            const card = [
                { name: 'right', x: centerX + radius + padding, y: centerY + 5, anchor: 'start' },
                { name: 'left', x: centerX - radius - padding, y: centerY + 5, anchor: 'end' },
                { name: 'below', x: centerX, y: centerY + radius + padding + 10, anchor: 'middle' },
                { name: 'above', x: centerX, y: centerY - radius - padding, anchor: 'middle' }
            ];

            const diagPad = padding;
            const diagOffset = (radius + diagPad) * 0.707;
            const extraX = 4;

            const diag = [
                { name: 'top-right', x: centerX + diagOffset + extraX, y: centerY - diagOffset, anchor: 'start' },
                { name: 'bottom-right', x: centerX + diagOffset + extraX, y: centerY + diagOffset + 5, anchor: 'start' },
                { name: 'bottom-left', x: centerX - diagOffset - extraX, y: centerY + diagOffset + 5, anchor: 'end' },
                { name: 'top-left', x: centerX - diagOffset - extraX, y: centerY - diagOffset, anchor: 'end' }
            ];

            return [...card, ...diag];
        }

        function hasCollision(textElement, obstacles, ignoreCircle) {
            try {
                const rawBBox = textElement.getBBox();
                const pad = 2;
                const textBBox = {
                    x: rawBBox.x + pad,
                    y: rawBBox.y + pad,
                    width: Math.max(0, rawBBox.width - pad * 2),
                    height: Math.max(0, rawBBox.height - pad * 2)
                };

                for (const obs of obstacles) {
                    if (obs.isCircle && obs.ref === ignoreCircle) continue;

                    if (rectanglesOverlap(textBBox, obs)) {
                        return true;
                    }
                }
                return false;
            } catch (e) {
                return false;
            }
        }

        function isOutOfBounds(textElement, bounds) {
            if (!bounds) return false;
            try {
                const bbox = textElement.getBBox();
                const margin = 5;
                if (bbox.x < bounds.x + margin ||
                    bbox.y < bounds.y + margin ||
                    (bbox.x + bbox.width) > (bounds.x + bounds.width - margin) ||
                    (bbox.y + bbox.height) > (bounds.y + bounds.height - margin)) {
                    return true;
                }
                return false;
            } catch (e) {
                return false;
            }
        }

        function findBestPosition(textElement, centerX, centerY, radius, obstacles, fullText, bounds, currentCircle, manualDirection) {
            const positions = getPositionOptions(centerX, centerY, radius);
            const truncatedText = truncateText(fullText, 35);

            if (manualDirection !== undefined && manualDirection !== null) {
                const directionMap = {
                    0: 'right',
                    1: 'bottom-right',
                    2: 'below',
                    3: 'bottom-left',
                    4: 'left',
                    5: 'top-left',
                    6: 'above',
                    7: 'top-right'
                };

                const dir = directionMap[manualDirection];
                const manualPos = positions.find(p => p.name === dir);
                if (manualPos) {
                    textElement.textContent = fullText;
                    textElement.setAttribute('x', manualPos.x);
                    textElement.setAttribute('y', manualPos.y);
                    textElement.setAttribute('text-anchor', manualPos.anchor);

                    const isColliding = hasCollision(textElement, obstacles, currentCircle);
                    return { ...manualPos, text: fullText, hasCollision: isColliding, isManual: true };
                }
            }

            let hasCollisionWithFull = false;

            textElement.textContent = fullText;
            for (const pos of positions) {
                textElement.setAttribute('x', pos.x);
                textElement.setAttribute('y', pos.y);
                textElement.setAttribute('text-anchor', pos.anchor);

                if (!hasCollision(textElement, obstacles, currentCircle) && !isOutOfBounds(textElement, bounds)) {
                    return { ...pos, text: fullText, hasCollision: false };
                }
            }

            hasCollisionWithFull = true;

            hasCollisionWithFull = true;

            textElement.textContent = truncatedText;
            for (const pos of positions) {
                textElement.setAttribute('x', pos.x);
                textElement.setAttribute('y', pos.y);
                textElement.setAttribute('text-anchor', pos.anchor);

                if (!hasCollision(textElement, obstacles, currentCircle) && !isOutOfBounds(textElement, bounds)) {
                    return { ...pos, text: truncatedText, hasCollision: hasCollisionWithFull };
                }
            }

            return { ...positions[0], text: truncatedText, hasCollision: true };
        }

        function getBoundData(element) {
            if (element.__data__) {
                return element.__data__;
            }

            let parent = element.parentElement;
            while (parent) {
                if (parent.__data__) {
                    return parent.__data__;
                }
                parent = parent.parentElement;
            }

            return null;
        }

        function findMatchingDataPoint(circle) {
            const bound = circle.__data__ || d3.select(circle).datum();
            if (bound) return bound;
            console.warn('No data bound to circle:', circle);
            return null;
        }

        let data = [];
        let allData = [];
        let viz;
        let xDomain, xStep, yDomainGlobal;
        let customLabels = [];
        let isUpdating = false;
        let hoveringElements = new Set();
        let activeFilters = new Set();

        const colors = {
            "Asia": "#e28f26",
            "Europe": "#365a94",
            "North America": "#800020",
            "Oceania": "#2d7c2d",
            "South America": "#669999",
            "Africa": "#8cab79"
        };

        async function loadData(type) {
            const fileName = type === 'donors' ? 'donors.json' : 'recipients_focused.json';
            const isDonor = type === 'donors';

            try {
                const response = await fetch(fileName);
                const rawJson = await response.json();

                removeCustomLabels();

                data = rawJson.map(d => ({
                    ...d,
                    id: isDonor ? d.Entity : d.RecipientName,
                    x: d.USD_Disbursement,
                    y: isDonor ? d.DonorGDP : d.RecipientGDP,
                    parent: isDonor ? d.DonorRegion : d.RecipientRegion,
                    color: colors[isDonor ? d.DonorRegion : d.RecipientRegion] || "#ccc",
                    value: 1
                })).filter(d => d.x <= 4000 && d.y <= 12000);
                allData = data;

                renderLegend();
                updateViz(isDonor);

                activeFilters.clear();

                setTimeout(() => {
                    initializeCustomLabels();
                }, 500);

            } catch (e) {
                console.error("Error loading data", e);
            }
        }

        function removeCustomLabels() {
            customLabels.forEach(l => {
                if (l.text) l.text.remove();
                if (l.line) l.line.remove();
            });
            customLabels = [];
            document.querySelectorAll('.custom-label, .connector-line').forEach(e => e.remove());
            if (hoveringElements) hoveringElements.clear();
        }

        window.addEventListener('resize', () => {
            if (viz) viz.render();
            updateLabelPositions();
            draw45DegreeLine();
        });

        function updateViz(isDonor) {
            const xVals = data.map(d => d.x);
            const yVals = data.map(d => d.y);
            const medianX = median(xVals);
            const medianY = median(yVals);
            const minX = Math.min(...xVals);
            const maxX = Math.max(...xVals);
            xDomain = [minX - (minX * 0.1), 4000];
            xStep = (maxX - minX) * 0.05;

            const minY = Math.min(...yVals);
            const maxY = Math.max(...yVals);
            const yDomain = [minY - (minY * 0.1), 12000];
            yDomainGlobal = yDomain;

            const yTitle = isDonor ? "Donor GDP" : "Recipient GDP";

            if (viz) {
                viz.data(data)
                    .yConfig({ title: yTitle })
                    .yDomain(yDomain)
                    .xDomain(xDomain)

                    .tooltipConfig({
                        body: d => `<table class='tooltip-table'>
              <tr><td class='title'>USD Disbursement:</td><td class='data'>${d.x.toLocaleString()}</td></tr>
              <tr><td class='title'>${yTitle}:</td><td class='data'>${d.y.toLocaleString()}</td></tr>
              <tr><td class='title'>Entity:</td><td class='data'>${d.id}</td></tr>
            </table>`,
                        title: d => d.id
                    })
                    .render();
            } else {
                viz = new d3plus.Plot()
                    .select("#chart")
                    .data(data)

                    .groupBy(["parent", "id"])
                    .tooltipConfig({
                        body: d => `<table class='tooltip-table'>
              <tr><td class='title'>USD Disbursement:</td><td class='data'>${d.x.toLocaleString()}</td></tr>
              <tr><td class='title'>${yTitle}:</td><td class='data'>${d.y.toLocaleString()}</td></tr>
              <tr><td class='title'>Entity:</td><td class='data'>${d.id}</td></tr>
            </table>`,
                        title: d => d.id
                    })
                    .size("value")
                    .sizeMin(8)
                    .sizeMax(8)
                    .color("color")
                    .label("")
                    .shapeConfig({
                        Circle: {
                            labelConfig: { fontSize: 0 }
                        }
                    })
                    .yConfig({
                        title: yTitle,
                        titleConfig: { fontSize: () => 16 },
                        gridConfig: { stroke: "transparent" },
                        shapeConfig: { labelConfig: { fontSize: () => 16 } }
                    })
                    .yDomain(yDomain)
                    .xDomain(xDomain)
                    .xConfig({
                        title: "USD Disbursement",
                        titleConfig: { fontSize: () => 16 },
                        gridConfig: { stroke: "transparent" },
                        shapeConfig: { labelConfig: { fontSize: () => 16 } }
                    })
                    .legend(false)
                    .downloadButton(false)
                    .render();
            }
        }

        function renderLegend() {
            const legendEl = document.querySelector('.legend');
            legendEl.innerHTML = '';

            if (allData.length > 0 && allData[0].parent) {
                const groups = {};
                allData.forEach(d => {
                    if (!groups[d.parent]) groups[d.parent] = d.color;
                });

                Object.keys(groups).forEach(parent => {
                    const color = groups[parent];
                    const item = document.createElement('div');
                    item.className = 'legend-item interactive';
                    item.innerHTML = `<span class="box" style="background: ${color};"></span><span>${parent}</span>`;
                    item.onclick = () => toggleFilter(parent, item);
                    legendEl.appendChild(item);
                });
            }
        }

        function toggleFilter(parent, element) {
            if (activeFilters.has(parent)) {
                activeFilters.delete(parent);
                element.classList.remove('inactive');
            } else {
                activeFilters.add(parent);
                element.classList.add('inactive');
            }

            const elementParent = parent;
            const legends = document.querySelectorAll('.legend-item');
            legends.forEach(l => {
                if (l.innerText.includes(elementParent)) {
                    if (activeFilters.has(elementParent)) {
                        l.classList.add('inactive');
                    } else {
                        l.classList.remove('inactive');
                    }
                }
            });

            const filtered = (activeFilters.size === 0)
                ? allData
                : allData.filter(d => !activeFilters.has(d.parent));

            data = filtered;

            removeCustomLabels();

            viz.data(filtered).render();

            setTimeout(() => {
                initializeCustomLabels();
            }, 500);
        }

        loadData('donors');

        setTimeout(() => {
            startPositionUpdater();
        }, 500);

        function draw45DegreeLine() {
            const svg = document.querySelector('#chart svg');
            if (!svg || customLabels.length < 2) return;

            svg.querySelectorAll('.diagonal-line').forEach(e => e.remove());

            const screenCTM = svg.getScreenCTM();
            if (!screenCTM) return;
            const inverseCTM = screenCTM.inverse();

            function toSvgCoords(el) {
                const bbox = el.getBoundingClientRect();
                const pt = svg.createSVGPoint();
                pt.x = bbox.left + bbox.width / 2;
                pt.y = bbox.top + bbox.height / 2;
                return pt.matrixTransform(inverseCTM);
            }

            // Use two circles with different data values to compute the coordinate mapping
            const ref1 = customLabels[0];
            const ref2 = customLabels.find(l => l.data.x !== ref1.data.x && l.data.y !== ref1.data.y) || customLabels[1];

            const svg1 = toSvgCoords(ref1.circle);
            const svg2 = toSvgCoords(ref2.circle);

            const scaleX = (svg2.x - svg1.x) / (ref2.data.x - ref1.data.x);
            const offsetX = svg1.x - scaleX * ref1.data.x;
            const scaleY = (svg2.y - svg1.y) / (ref2.data.y - ref1.data.y);
            const offsetY = svg1.y - scaleY * ref1.data.y;

            // Origin (where axes meet) and opposite corner
            const x1 = scaleX * xDomain[0] + offsetX;
            const y1 = scaleY * yDomainGlobal[0] + offsetY;
            const x2 = scaleX * xDomain[1] + offsetX;
            const y2 = scaleY * yDomainGlobal[1] + offsetY;

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('class', 'diagonal-line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', '#999');
            line.setAttribute('stroke-width', '1');
            line.setAttribute('stroke-dasharray', '5,5');
            line.setAttribute('opacity', '0.5');

            // Insert behind data points
            const firstCircle = svg.querySelector('circle');
            if (firstCircle && firstCircle.parentElement) {
                firstCircle.parentElement.insertBefore(line, firstCircle);
            } else {
                svg.appendChild(line);
            }
        }

        function initializeCustomLabels() {
            const svg = document.querySelector('#chart svg');
            if (!svg) {
                setTimeout(initializeCustomLabels, 100);
                return;
            }

            const circles = svg.querySelectorAll('circle');
            console.log('Found circles:', circles.length);

            removeCustomLabels();

            circles.forEach((circle, index) => {
                let matchingData = findMatchingDataPoint(circle);

                if (matchingData) {
                    const originalData = data.find(d =>
                        d.id === matchingData.id ||
                        (d.parent + "_" + d.id) === matchingData.id
                    );
                    if (originalData) {
                        matchingData = originalData;
                    }

                    console.log('Circle', index, 'matched to data:', matchingData.id, 'Direction:', matchingData.labelDirection);

                    const fullText = matchingData.domain || matchingData.id;

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('class', 'custom-label');
                    text.setAttribute('data-id', matchingData.id);
                    text.setAttribute('text-anchor', 'start');
                    text.setAttribute('font-family', 'Arial, Helvetica, sans-serif');
                    text.setAttribute('font-size', '13');
                    if (matchingData.labelColor) {
                        text.setAttribute('fill', matchingData.labelColor);
                        text.style.fill = matchingData.labelColor;
                    } else {
                        text.setAttribute('fill', '#000');
                    }
                    text.setAttribute('font-weight', 'normal');
                    text.textContent = fullText;

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('class', 'connector-line');

                    svg.appendChild(line);
                    svg.appendChild(text);

                    customLabels.push({
                        circle: circle,
                        text: text,
                        line: line,
                        data: matchingData,
                        fullText: fullText,
                        defaultText: fullText,
                        savedPosition: null
                    });

                    circle.addEventListener('mouseenter', () => {
                        hoveringElements.add(text);

                        const labelData = customLabels.find(l => l.circle === circle);
                        if (labelData) {
                            labelData.savedPosition = {
                                x: text.getAttribute('x'),
                                y: text.getAttribute('y'),
                                anchor: text.getAttribute('text-anchor'),
                                content: text.textContent
                            };
                        }

                        text.classList.add('hover');
                        text.textContent = fullText;

                        console.log('Hovering over:', matchingData.id);
                    });

                    circle.addEventListener('mouseleave', () => {
                        hoveringElements.delete(text);

                        text.classList.remove('hover');

                        const labelData = customLabels.find(l => l.circle === circle);
                        if (labelData && labelData.savedPosition) {
                            text.setAttribute('x', labelData.savedPosition.x);
                            text.setAttribute('y', labelData.savedPosition.y);
                            text.setAttribute('text-anchor', labelData.savedPosition.anchor);
                            text.textContent = labelData.savedPosition.content;
                        }
                    });
                } else {
                    console.log('Circle', index, 'could not be matched to data');
                }
            });

            updateLabelPositions();
            draw45DegreeLine();
        }

        function updateLabelPositions() {
            if (isUpdating) return;
            isUpdating = true;

            const svg = document.querySelector('#chart svg');
            if (!svg) {
                isUpdating = false;
                return;
            }

            const chartDiv = document.getElementById('chart');
            const width = chartDiv ? chartDiv.clientWidth : window.innerWidth;
            let currentFontSize = 10;
            if (width < 600) currentFontSize = 8;
            else if (width < 900) currentFontSize = 9;

            customLabels.forEach(({ text }) => {
                if (text) {
                    text.setAttribute('font-size', currentFontSize);
                    text.style.fontSize = currentFontSize + 'px';
                }
            });

            const circlePositions = [];

            customLabels.forEach(({ circle, text }) => {
                if (circle && text) {
                    const bbox = circle.getBoundingClientRect();
                    const svgRect = svg.getBoundingClientRect();

                    const svgPoint = svg.createSVGPoint();
                    svgPoint.x = bbox.left + bbox.width / 2 - svgRect.left;
                    svgPoint.y = bbox.top + bbox.height / 2 - svgRect.top;

                    const screenCTM = svg.getScreenCTM();
                    if (screenCTM) {
                        const svgCoords = svgPoint.matrixTransform(screenCTM.inverse());
                        circlePositions.push({
                            circle: circle,
                            coords: svgCoords
                        });
                    }
                }
            });

            const obstacles = circlePositions.map(c => {
                const r = parseFloat(c.circle.getAttribute('r')) || 7.5;
                return {
                    x: c.coords.x - r,
                    y: c.coords.y - r,
                    width: r * 2,
                    height: r * 2,
                    isCircle: true,
                    ref: c.circle
                };
            });

            let bounds = null;
            if (svg) {
                try {
                    const screenCTM = svg.getScreenCTM();
                    if (screenCTM) {
                        const inverseCTM = screenCTM.inverse();
                        const rect = svg.getBoundingClientRect();

                        const p1 = svg.createSVGPoint();
                        p1.x = rect.left;
                        p1.y = rect.top;
                        const min = p1.matrixTransform(inverseCTM);

                        const p2 = svg.createSVGPoint();
                        p2.x = rect.right;
                        p2.y = rect.bottom;
                        const max = p2.matrixTransform(inverseCTM);

                        bounds = {
                            x: min.x,
                            y: min.y,
                            width: max.x - min.x,
                            height: max.y - min.y
                        };
                    }
                } catch (e) {
                    console.log('Error calculating bounds', e);
                }
            }

            customLabels.forEach((labelData) => {
                const { circle, text, line, fullText } = labelData;

                if (hoveringElements.has(text)) {
                    return;
                }

                if (circle && text) {
                    const circleData = circlePositions.find(cp => cp.circle === circle);
                    if (circleData) {
                        const r = parseFloat(circle.getAttribute('r')) || 7.5;
                        const bestPosition = findBestPosition(
                            text,
                            circleData.coords.x,
                            circleData.coords.y,
                            r,
                            obstacles,
                            fullText,
                            bounds,
                            circle,
                            labelData.data ? labelData.data.labelDirection : null
                        );

                        text.setAttribute('x', bestPosition.x);
                        text.setAttribute('y', bestPosition.y);
                        text.setAttribute('text-anchor', bestPosition.anchor);
                        text.textContent = bestPosition.text;
                        labelData.defaultText = bestPosition.text;

                        if (bestPosition.hasCollision && !bestPosition.isManual) {
                            text.classList.add('collision');
                            text.setAttribute('opacity', '0.3');
                        } else {
                            text.classList.remove('collision');
                            text.setAttribute('opacity', '1');
                        }

                        if (line) {
                            line.setAttribute('opacity', (bestPosition.hasCollision && !bestPosition.isManual) ? '0.2' : '0.5');

                            const cx = circleData.coords.x;
                            const cy = circleData.coords.y;
                            let lx1, ly1, lx2, ly2;

                            const name = bestPosition.name;

                            lx1 = cx; ly1 = cy;
                            lx2 = bestPosition.x; ly2 = bestPosition.y;

                            if (name === 'right') {
                                lx1 = cx + r; ly1 = cy;
                                lx2 = bestPosition.x - 2; ly2 = cy;
                            } else if (name === 'left') {
                                lx1 = cx - r; ly1 = cy;
                                lx2 = bestPosition.x + 2; ly2 = cy;
                            } else if (name === 'above') {
                                lx1 = cx; ly1 = cy - r;
                                lx2 = cx; ly2 = bestPosition.y + 2;
                            } else if (name === 'below') {
                                lx1 = cx; ly1 = cy + r;
                                lx2 = cx; ly2 = bestPosition.y - 12;
                            } else if (name === 'top-right') {
                                lx1 = cx + r * 0.7; ly1 = cy - r * 0.7;
                                lx2 = bestPosition.x - 2; ly2 = bestPosition.y - 4;
                            } else if (name === 'bottom-right') {
                                lx1 = cx + r * 0.7; ly1 = cy + r * 0.7;
                                lx2 = bestPosition.x - 2; ly2 = bestPosition.y - 5;
                            } else if (name === 'bottom-left') {
                                lx1 = cx - r * 0.7; ly1 = cy + r * 0.7;
                                lx2 = bestPosition.x + 2; ly2 = bestPosition.y - 5;
                            } else if (name === 'top-left') {
                                lx1 = cx - r * 0.7; ly1 = cy - r * 0.7;
                                lx2 = bestPosition.x + 2; ly2 = bestPosition.y - 4;
                            }

                            line.setAttribute('x1', lx1);
                            line.setAttribute('y1', ly1);
                            line.setAttribute('x2', lx2);
                            line.setAttribute('y2', ly2);
                        }

                        const bbox = text.getBBox();
                        obstacles.push({
                            x: bbox.x,
                            y: bbox.y,
                            width: bbox.width,
                            height: bbox.height,
                            isCircle: false
                        });
                    }
                }
            });

            isUpdating = false;
        }

        function startPositionUpdater() {
            function updateLoop() {
                updateLabelPositions();
                requestAnimationFrame(updateLoop);
            }

            updateLoop();

            const chartElement = document.getElementById('chart');
            if (chartElement) {
                chartElement.addEventListener('wheel', updateLabelPositions, { passive: true });
                chartElement.addEventListener('mousedown', updateLabelPositions);
                chartElement.addEventListener('mousemove', updateLabelPositions);
                chartElement.addEventListener('mouseup', updateLabelPositions);
            }
        }


        document.addEventListener('keydown', (e) => {
            if (e.key === "1") {
                loadData('donors');
            }
            if (e.key === "2") {
                loadData('recipients');
            }

            if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
                if (e.key === "ArrowRight") {
                    xDomain[1] += xStep;
                } else if (e.key === "ArrowLeft") {
                    xDomain[1] -= xStep;
                    if (xDomain[1] <= xDomain[0] + xStep) xDomain[1] = xDomain[0] + xStep;
                }

                console.log("New X Domain:", xDomain);
                viz.xDomain([...xDomain]).render();
                setTimeout(() => {
                    initializeCustomLabels();
                }, 200);
            }
        });
    </script>
    <div style="position:fixed;right:10px;bottom:10px;font-size:11px;color:#888;z-index:9999;">
    </div>
</body>

</html>