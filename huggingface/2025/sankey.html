<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>OpenAlex Sankey</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      height: 100vh;
      font-family: "Inter", "Segoe UI", Arial, sans-serif;
      background: #f4f6fb;
      color: #1f2933;
    }

    .viz-grid {
      display: grid;
      grid-template-rows: 19fr 1fr;
      grid-template-columns: 1fr 1fr;
      gap: clamp(8px, 1vh, 18px);
      height: 100vh;
      width: 100vw;
      padding: clamp(12px, 2vh, 24px);
      box-sizing: border-box;
    }

    .container {
      border-radius: 16px;
      background: transparent;
      box-shadow: none;
    }

    #container1 {
      grid-row: 1;
      grid-column: 1 / span 2;
      display: flex;
      flex-direction: column;
      padding: 0;
      position: relative;
      overflow: hidden;
    }

    #container3 {
      grid-row: 2;
      grid-column: 1;
      display: flex;
      align-items: center;
      padding: 0 clamp(12px, 2vw, 20px);
      overflow: hidden;
    }

    #container4 {
      grid-row: 2;
      grid-column: 2;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding: 0 clamp(12px, 2vw, 20px);
      overflow: hidden;
    }

    #container4 a {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
    }

    #refresh-button {
      margin-right: clamp(12px, 2vw, 20px);
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      background: #2756d3;
      color: #fff;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    #refresh-button:disabled {
      opacity: 0.6;
      cursor: default;
    }

    #refresh-button:not(:disabled):hover {
      background: #1c3e99;
    }

    #viz {
      width: 100%;
      height: 100%;
      flex: 1;
      min-height: 0;
      min-width: 0;
      position: relative;
    }

    #viz svg,
    #viz canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    #viz canvas {
      z-index: 1;
      pointer-events: none;
    }

    #viz svg {
      z-index: 2;
    }

    .source-text {
      font-size: clamp(12px, 1.5vw, 16px);
      font-weight: 600;
      color: #475569;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .source-text a {
      color: #2756d3;
      text-decoration: none;
    }

    .source-text a:hover {
      text-decoration: underline;
    }

    .logo {
      height: 100%;
      width: auto;
      max-height: clamp(36px, 6vh, 60px);
      max-width: 100%;
      pointer-events: auto;
      object-fit: contain;
    }

    .links path {
      fill: none;
      stroke-opacity: 0.4;
      transition: all 0.3s ease;
    }

    .nodes rect {
      stroke-width: 1px;
      transition: all 0.3s ease;
    }

    .nodes text {
      font-size: 14px;
      pointer-events: none;
      transition: all 0.3s ease;
    }

    .hoveredNode rect {
      filter: drop-shadow(0 0 5px #fff);
      stroke-width: 2px;
    }

    .hoveredNode text {
      font-size: 16px;
      stroke: #fff;
      stroke-width: 2px;
      paint-order: stroke fill;
      font-weight: bold;
    }

    .hoveredLink {
      stroke-opacity: 1 !important;
      filter: drop-shadow(0 0 5px #fff);
    }

    .dimmedNode rect {
      fill: #ccc !important;
      stroke: #ccc !important;
      filter: none;
    }

    .dimmedNode text {
      fill: #666 !important;
      stroke: none;
      font-weight: normal;
      font-size: 14px;
    }

    .dimmedLink {
      stroke: #ccc !important;
      filter: none;
    }

    .tooltip {
      position: absolute;
      text-align: left;
      padding: 8px 10px;
      background: rgba(255, 255, 255, 0.98);
      border: 1px solid rgba(39, 86, 211, 0.2);
      font-size: 12px;
      border-radius: 8px;
      box-shadow: 0 12px 24px rgba(15, 23, 42, 0.12);
      pointer-events: none;
      opacity: 0;
      color: #0f172a;
      z-index: 9999;
    }

    .particle {
      fill: #fff;
      stroke: rgba(255, 255, 255, 0.8);
      stroke-width: 1px;
      filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.6));
      pointer-events: none;
    }

    @media (max-height: 500px) {
      .viz-grid {
        grid-template-rows: 1fr;
        grid-template-columns: 1fr;
        padding: 12px;
      }

      #container1 {
        grid-row: 1;
        grid-column: 1;
      }

      #container3,
      #container4 {
        display: none !important;
      }
    }
  </style>
</head>

<body>
  <div class="viz-grid">
    <div id="container1" class="container viz-container">
      <div id="viz">
        <canvas id="particle-canvas"></canvas>
        <svg id="sankey"></svg>
      </div>
    </div>
    <div id="container3" class="container source-container">
      <div class="source-text">
        Source:
        <a href="https://huggingface.co" target="_blank" rel="noopener">
          HuggingFace
        </a>
      </div>
    </div>
    <div id="container4" class="container logo-container">
      <button id="refresh-button" type="button">Refresh data</button>
      <a href="https://aiworld.eu/" target="_blank" rel="noopener">
        <img src="https://aiworld.eu/logo-transparent.svg" class="logo" alt="AI World logo" />
      </a>
    </div>
  </div>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <script>
    const DATA_URL = 'https://docs.google.com/spreadsheets/d/1mO4uUE0aMCy2WODJKakUSf4dCNtSJn84sU-WaWluL80/export?format=csv';
    const vizContainer = document.getElementById('viz');
    const svg = d3.select('#sankey');
    const tooltip = d3.select('body').append('div')
      .attr('class', 'tooltip');
    const refreshButton = document.getElementById('refresh-button');
    const particleCanvas = document.getElementById('particle-canvas');
    const particleContext = particleCanvas ? particleCanvas.getContext('2d') : null;

    let width = 0;
    let height = 0;
    let cleanData = [];
    let nodeColorMap = new Map();
    let particles = [];
    let particleLinks = [];
    let particleTimer = null;
    let hoveredLinkIds = new Set();

    const PARTICLE_TIMER_DELAY = 800;
    const PARTICLE_SETTINGS = {
      frequencyRange: [0.08, 0.65],
      sizeRange: [1.5, 4],
      speedRange: [0.15, 0.54],
      emissionIterations: 2,
      densityScale: 0.02
    };

    const sankey = d3.sankey()
      .nodeWidth(20)
      .nodePadding(16);

    const linkPath = d3.sankeyLinkHorizontal();

    function updateDimensions() {
      const rect = vizContainer.getBoundingClientRect();
      width = rect.width || window.innerWidth;
      height = rect.height || window.innerHeight;
      svg
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', `0 0 ${width} ${height}`);
      sankey.size([width, height]);
      if (particleCanvas) {
        particleCanvas.width = width;
        particleCanvas.height = height;
      }
    }

    function positionTooltip(event) {
      const tooltipOffset = 10;
      const screenWidth = window.innerWidth;
      const isLeftSide = event.pageX < screenWidth / 2;

      if (isLeftSide) {
        // Mouse is on left side, show tooltip to the right
        tooltip
          .style('left', `${event.pageX + tooltipOffset}px`)
          .style('top', `${event.pageY - 28}px`);
      } else {
        // Mouse is on right side, show tooltip to the left
        const tooltipNode = tooltip.node();
        const tooltipWidth = tooltipNode ? tooltipNode.offsetWidth : 150;
        tooltip
          .style('left', `${event.pageX - tooltipWidth - tooltipOffset}px`)
          .style('top', `${event.pageY - 28}px`);
      }
    }

    function setHoveredLinks(links) {
      const linkArray = Array.isArray(links) ? links : Array.from(links || []);
      const idSet = new Set();
      linkArray.forEach(link => {
        if (link && link.id) {
          idSet.add(link.id);
        }
      });
      hoveredLinkIds = idSet;
      return hoveredLinkIds;
    }

    function clearHoveredLinks() {
      hoveredLinkIds = new Set();
      return hoveredLinkIds;
    }

    function buildGraph(data) {
      if (!data.length) {
        return { nodes: [], links: [], levelCount: 0 };
      }

      const nodeNames = new Set();
      const linkKeyMap = new Map();

      data.forEach(d => {
        nodeNames.add(d.from);
        nodeNames.add(d.to);

        const key = `${d.from}|${d.to}`;
        let link = linkKeyMap.get(key);
        if (!link) {
          link = {
            id: key,
            sourceName: d.from,
            targetName: d.to,
            value: 0
          };
          linkKeyMap.set(key, link);
        }
        link.value += d.value;
      });

      const adjacency = new Map();
      const indegree = new Map();
      nodeNames.forEach(name => {
        adjacency.set(name, new Set());
        indegree.set(name, 0);
      });

      linkKeyMap.forEach(link => {
        if (!adjacency.has(link.sourceName)) {
          adjacency.set(link.sourceName, new Set());
        }
        adjacency.get(link.sourceName).add(link.targetName);
        indegree.set(link.targetName, (indegree.get(link.targetName) || 0) + 1);
      });

      const levels = new Map();
      const queue = [];

      nodeNames.forEach(name => {
        if ((indegree.get(name) || 0) === 0) {
          queue.push(name);
          levels.set(name, 0);
        }
      });

      while (queue.length) {
        const current = queue.shift();
        const currentLevel = levels.get(current) || 0;
        const neighbors = adjacency.get(current);
        if (!neighbors) continue;
        neighbors.forEach(target => {
          const candidate = currentLevel + 1;
          const existing = levels.get(target);
          if (existing === undefined || candidate > existing) {
            levels.set(target, candidate);
          }
          indegree.set(target, (indegree.get(target) || 0) - 1);
          if ((indegree.get(target) || 0) === 0) {
            queue.push(target);
          }
        });
      }

      nodeNames.forEach(name => {
        if (!levels.has(name)) {
          levels.set(name, 0);
        }
      });

      const sortedNames = Array.from(nodeNames).sort((a, b) => {
        const levelDiff = (levels.get(a) || 0) - (levels.get(b) || 0);
        return levelDiff !== 0 ? levelDiff : a.localeCompare(b);
      });

      const nodes = sortedNames.map(name => ({
        name,
        level: levels.get(name) || 0,
        color: nodeColorMap.get(name) || '#b3b3b3'
      }));

      const nodeIndexMap = new Map(nodes.map((node, index) => [node.name, index]));

      const links = Array.from(linkKeyMap.values())
        .map(link => ({
          id: link.id || `${link.sourceName}|${link.targetName}`,
          source: nodeIndexMap.get(link.sourceName),
          target: nodeIndexMap.get(link.targetName),
          value: link.value,
          color: nodeColorMap.get(link.sourceName) || '#999'
        }))
        .filter(link => link.source !== undefined && link.target !== undefined && link.value > 0);

      const levelCount = nodes.length
        ? nodes.reduce((max, node) => Math.max(max, node.level), 0) + 1
        : 0;

      return { nodes, links, levelCount };
    }

    function render() {
      resetParticles();
      if (!cleanData.length) {
        return;
      }

      updateDimensions();
      svg.selectAll('*').remove();

      const graph = buildGraph(cleanData);

      sankey.nodeAlign((node, columns) => {
        const maxColumns = Number.isFinite(columns) ? columns : (graph.levelCount ? graph.levelCount - 1 : 0);
        const maxLevel = graph.levelCount ? Math.min(graph.levelCount - 1, maxColumns) : maxColumns;
        const nodeLevel = typeof node.level === 'number' ? node.level : 0;
        return Math.max(0, Math.min(nodeLevel, maxLevel));
      });

      sankey(graph);

      const linkSelection = svg.append('g')
        .attr('class', 'links')
        .selectAll('path')
        .data(graph.links)
        .enter().append('path')
        .attr('d', linkPath)
        .attr('stroke-width', d => Math.max(1, d.width))
        .attr('stroke', d => d.color);

      const nodeSelection = svg.append('g')
        .attr('class', 'nodes')
        .selectAll('g')
        .data(graph.nodes)
        .enter().append('g')
        .attr('transform', d => `translate(${d.x0},${d.y0})`);

      nodeSelection.append('rect')
        .attr('height', d => d.y1 - d.y0)
        .attr('width', sankey.nodeWidth())
        .attr('fill', d => d.color || '#b3b3b3')
        .attr('stroke', '#999');

      nodeSelection.append('text')
        .attr('x', -6)
        .attr('y', d => (d.y1 - d.y0) / 2)
        .attr('dy', '0.35em')
        .attr('text-anchor', 'end')
        .attr('fill', '#000')
        .text(d => d.name)
        .filter(d => d.x0 < width / 2)
        .attr('x', 6 + sankey.nodeWidth())
        .attr('text-anchor', 'start');

      nodeSelection
        .on('mouseover', function (d) {
          d3.select(this).style('cursor', 'pointer');
          tooltip.transition().duration(200).style('opacity', 0.95);
          const columnText = graph.levelCount ? `Column: ${Math.min(d.level + 1, graph.levelCount)} / ${graph.levelCount}` : '';
          const nodeTooltip = columnText
            ? `Name: ${d.name}<br/>Total: ${d.value}<br/>${columnText}`
            : `Name: ${d.name}<br/>Total: ${d.value}`;
          tooltip.html(nodeTooltip);
          positionTooltip(d3.event);

          const nodeIndex = d.index;
          const connectedLinks = graph.links.filter(l => l.source.index === nodeIndex || l.target.index === nodeIndex);
          const connectedNodes = new Set([nodeIndex]);
          const connectedLinkIds = setHoveredLinks(connectedLinks);
          connectedLinks.forEach(l => {
            connectedNodes.add(l.source.index);
            connectedNodes.add(l.target.index);
          });

          nodeSelection.classed('dimmedNode', true).classed('hoveredNode', false);
          linkSelection.classed('dimmedLink', true).classed('hoveredLink', false);

          nodeSelection.filter(nd => connectedNodes.has(nd.index))
            .classed('dimmedNode', false)
            .classed('hoveredNode', true);
          linkSelection.filter(ld => connectedLinkIds.has(ld.id))
            .classed('dimmedLink', false)
            .classed('hoveredLink', true);
        })
        .on('mousemove', function () {
          positionTooltip(d3.event);
        })
        .on('mouseout', function () {
          tooltip.transition().duration(200).style('opacity', 0);
          clearHoveredLinks();
          nodeSelection.classed('hoveredNode', false).classed('dimmedNode', false);
          linkSelection.classed('hoveredLink', false).classed('dimmedLink', false);
          d3.select(this).style('cursor', null);
        });

      linkSelection
        .on('mouseover', function (d) {
          d3.select(this).style('cursor', 'pointer');
          tooltip.transition().duration(200).style('opacity', 0.95);
          const sourceName = graph.nodes[d.source.index].name;
          const targetName = graph.nodes[d.target.index].name;
          const sourceLevel = graph.levelCount ? `${Math.min((d.source.level || 0) + 1, graph.levelCount)}` : null;
          const targetLevel = graph.levelCount ? `${Math.min((d.target.level || 0) + 1, graph.levelCount)}` : null;
          const levelInfo = (sourceLevel && targetLevel)
            ? `<br/>Columns: ${sourceLevel} -> ${targetLevel} / ${graph.levelCount}`
            : '';
          tooltip.html(`Source: ${sourceName}<br/>Target: ${targetName}<br/>Value: ${d.value}`);
          positionTooltip(d3.event);

          const connectedNodes = new Set([d.source.index, d.target.index]);
          setHoveredLinks([d]);
          nodeSelection.classed('dimmedNode', true).classed('hoveredNode', false);
          linkSelection.classed('dimmedLink', true).classed('hoveredLink', false);

          nodeSelection.filter(nd => connectedNodes.has(nd.index))
            .classed('dimmedNode', false)
            .classed('hoveredNode', true);
          d3.select(this).classed('dimmedLink', false).classed('hoveredLink', true);
        })
        .on('mousemove', function () {
          positionTooltip(d3.event);
        })
        .on('mouseout', function () {
          tooltip.transition().duration(200).style('opacity', 0);
          clearHoveredLinks();
          nodeSelection.classed('hoveredNode', false).classed('dimmedNode', false);
          linkSelection.classed('hoveredLink', false).classed('dimmedLink', false);
          d3.select(this).style('cursor', null);
        });

      startParticleFlow(graph, linkSelection);
    }

    function resetParticles() {
      if (particleTimer) {
        particleTimer.stop();
        particleTimer = null;
      }
      particles = [];
      particleLinks = [];
      clearHoveredLinks();
      if (particleContext && particleCanvas) {
        particleContext.clearRect(0, 0, particleCanvas.width || width, particleCanvas.height || height);
      }
    }

    function startParticleFlow(graph, linkSelection) {
      if (!particleContext || !particleCanvas || !graph.links.length) {
        return;
      }

      const values = graph.links.map(l => l.value);
      const extent = d3.extent(values);
      if (!extent || !Number.isFinite(extent[0]) || !Number.isFinite(extent[1])) {
        return;
      }
      const normalizedExtent = extent[0] === extent[1]
        ? [extent[0], extent[0] + 1]
        : extent;

      const frequencyScale = d3.scaleLinear()
        .domain(normalizedExtent)
        .range(PARTICLE_SETTINGS.frequencyRange);
      const sizeScale = d3.scaleLinear()
        .domain(normalizedExtent)
        .range(PARTICLE_SETTINGS.sizeRange);

      particleLinks = [];
      linkSelection.each(function (d) {
        const sourceColor = d.source.color || (graph.nodes[d.source.index] && graph.nodes[d.source.index].color) || '#999';
        const targetColor = d.target.color || (graph.nodes[d.target.index] && graph.nodes[d.target.index].color) || '#ccc';
        const freqValue = frequencyScale(d.value);
        const clampedFreq = Math.max(PARTICLE_SETTINGS.frequencyRange[0], Math.min(freqValue, PARTICLE_SETTINGS.frequencyRange[1]));
        d.freq = clampedFreq * PARTICLE_SETTINGS.densityScale;
        d.particleSize = sizeScale(d.value);
        d.particleColor = d3.scaleLinear().domain([0, 1]).range([sourceColor, targetColor]);
        particleLinks.push({ link: d, path: this });
      });

      if (particleTimer) {
        particleTimer.stop();
      }
      particles = [];

      particleTimer = d3.timer((elapsed) => {
        tickParticles(elapsed);
      }, PARTICLE_TIMER_DELAY);
    }

    function tickParticles(elapsed) {
      particles = particles.filter(p => p.current < p.length && p.path);
      particleLinks.forEach(({ link, path }) => {
        if (!path || !link.freq) {
          return;
        }
        for (let i = 0; i < PARTICLE_SETTINGS.emissionIterations; i += 1) {
          if (Math.random() < link.freq) {
            const offsetRange = Math.max(1, (link.width || 2) - (link.particleSize || 1));
            const offset = (Math.random() - 0.5) * offsetRange;
            const totalLength = path.getTotalLength();
            particles.push({
              link,
              path,
              length: totalLength,
              startTime: elapsed,
              offset,
              speed: PARTICLE_SETTINGS.speedRange[0] +
                Math.random() * (PARTICLE_SETTINGS.speedRange[1] - PARTICLE_SETTINGS.speedRange[0])
            });
          }
        }
      });
      drawParticles(elapsed);
    }

    function drawParticles(elapsed) {
      if (!particleContext || !particleCanvas) {
        return;
      }
      particleContext.clearRect(0, 0, particleCanvas.width || width, particleCanvas.height || height);
      particles.forEach(p => {
        const elapsedTime = elapsed - p.startTime;
        p.current = elapsedTime * 0.15 * p.speed;
        if (p.current > p.length) {
          return;
        }
        const currentPos = p.path.getPointAtLength(p.current);
        if (!currentPos) {
          return;
        }
        particleContext.beginPath();
        const hasHoveredId = p.link && p.link.id && hoveredLinkIds.has(p.link.id);
        const hasHoveredClass = p.path && p.path.classList && p.path.classList.contains('hoveredLink');
        const isHovered = hasHoveredId || hasHoveredClass;
        const fill = isHovered
          ? '#ffffff'
          : (typeof p.link.particleColor === 'function'
              ? p.link.particleColor(Math.random())
              : (p.link.color || '#999'));

        particleContext.fillStyle = fill;
        particleContext.arc(
          currentPos.x,
          currentPos.y + p.offset,
          p.link.particleSize || 2,
          0,
          2 * Math.PI
        );
        particleContext.fill();
      });
    }

    function setRefreshing(isLoading) {
      if (!refreshButton) return;
      refreshButton.disabled = isLoading;
      refreshButton.textContent = isLoading ? 'Refreshingâ€¦' : 'Refresh';
    }

    function loadData() {
      setRefreshing(true);
      d3.csv(DATA_URL).then(rows => {
        cleanData = rows
          .map(row => {
            const from = row.from ? row.from.trim() : null;
            const to = row.to ? row.to.trim() : null;
            const color = row.color ? row.color.trim() : null;
            const value = row.count ? +row.count : NaN;
            return { from, to, color, value };
          })
          .filter(d => d.from && d.to && Number.isFinite(d.value));

        nodeColorMap = new Map();

        cleanData.forEach(d => {
          if (d.color && !nodeColorMap.has(d.from)) {
            nodeColorMap.set(d.from, d.color);
          }
        });

        render();
      }).catch(error => {
        console.error('Unable to load data', error);
      }).finally(() => {
        setRefreshing(false);
      });
    }

    if (refreshButton) {
      refreshButton.addEventListener('click', loadData);
    }
    window.addEventListener('resize', render);
    loadData();
  </script>
</body>

</html>
