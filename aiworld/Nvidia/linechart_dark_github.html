<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>HF Orgs Line Chart v2.0</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
:root {
  --viz-body-bg: #ffffff;
  --viz-body-text: #111111;
  --viz-title-color: #101a35;
  --viz-subtitle-color: #1f2a44;
  --viz-axis-label: #333333;
  --viz-divider: rgba(0,0,0,0.1);
  --viz-card-bg: #ffffff;
  --viz-panel-bg: rgba(255,255,255,0.95);
  --viz-panel-surface: rgba(255,255,255,0.72);
  --viz-tooltip-bg: #ffffff;
  --viz-tooltip-border: #d9d9df;
  --viz-muted-text: #6e7485;
  --viz-source-text: #333333;
  --viz-link-color: #2756d3;
  --viz-axis-line: #cfd2d7;
  --viz-grid-line: rgba(230,232,239,0.45);
  --viz-border-color: #cfd2d7;
  --viz-control-bg: #ffffff;
  --viz-control-text: #1f2a44;
  --viz-track-bg: #e2e5f1;
  --viz-selection-color: #2756d3;
  --viz-disabled-border: #aeb4c4;
  --viz-disabled-fill: #f0f1f5;
  --viz-elevation-shadow: rgba(0,0,0,0.18);
  color-scheme: light;
}

body.theme-dark {
  --viz-body-bg: #000000; /* pure black */
  --viz-card-bg: #000000;
  --viz-panel-bg: rgba(0, 0, 0, 0.95);
  --viz-panel-surface: rgba(0, 0, 0, 0.9);
  --viz-tooltip-bg: #000000;
  --viz-control-bg: #000000;

  --viz-body-text: #e2e8f0;
  --viz-title-color: #f8fafc;
  --viz-subtitle-color: #cbd5f5;
  --viz-axis-label: #cbd5f5;
  --viz-divider: rgba(148,163,184,0.3);
  --viz-tooltip-border: rgba(148,163,184,0.45);
  --viz-muted-text: #8da2c9;
  --viz-source-text: #cbd5f5;
  --viz-link-color: #93c5fd;
  --viz-axis-line: rgba(148,163,184,0.45);
  --viz-grid-line: rgba(71,85,105,0.45);
  --viz-border-color: rgba(148,163,184,0.35);
  --viz-control-text: #e2e8f0;
  --viz-track-bg: rgba(46,64,104,0.78);
  --viz-selection-color: #4f8bff;
  --viz-disabled-border: rgba(148,163,184,0.3);
  --viz-disabled-fill: rgba(45,55,72,0.75);
  --viz-elevation-shadow: rgba(0, 0, 0, 0.65);

  color-scheme: dark;
  background-color: var(--viz-body-bg);
  color: var(--viz-body-text);
}
/* 
body.theme-dark {
  --viz-body-bg: #0b1120;
  --viz-body-text: #e2e8f0;
  --viz-title-color: #f8fafc;
  --viz-subtitle-color: #cbd5f5;
  --viz-axis-label: #cbd5f5;
  --viz-divider: rgba(148,163,184,0.3);
  --viz-card-bg: #16213a;
  --viz-panel-bg: rgba(15,23,42,0.92);
  --viz-panel-surface: rgba(15,23,42,0.82);
  --viz-tooltip-bg: #111c2f;
  --viz-tooltip-border: rgba(148,163,184,0.45);
  --viz-muted-text: #8da2c9;
  --viz-source-text: #cbd5f5;
  --viz-link-color: #93c5fd;
  --viz-axis-line: rgba(148,163,184,0.45);
  --viz-grid-line: rgba(71,85,105,0.45);
  --viz-border-color: rgba(148,163,184,0.35);
  --viz-control-bg: #15213a;
  --viz-control-text: #e2e8f0;
  --viz-track-bg: rgba(46,64,104,0.78);
  --viz-selection-color: #4f8bff;
  --viz-disabled-border: rgba(148,163,184,0.3);
  --viz-disabled-fill: rgba(45,55,72,0.75);
  --viz-elevation-shadow: rgba(7,12,24,0.65);
  color-scheme: dark;
} */

html, body { height: 100%; }
body { 
    margin: 0; 
    overflow: hidden; 
    background: var(--viz-body-bg, #ffffff); 
    color: var(--viz-body-text, #111); 
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, sans-serif; 
    height: 100vh; 
}
.viz-grid { 
  display: grid; 
  grid-template-rows: auto var(--row-chart,17fr) var(--row-slider,3fr) 1fr; 
  grid-template-columns: 1fr 1fr; 
  height: 100vh; 
  width: 100%; 
  box-sizing: border-box; 
  padding-bottom: clamp(4px, 2vh, 10px); 
}

.viz-layout { 
    position: relative; 
    width: 100%; 
    height: 100vh; 
    min-height: 100vh; 
    display: flex; 
    align-items: stretch; 
    justify-content: flex-start; 
    overflow: hidden; 
    min-width: 0; 
}

.viz-download-button { 
    width: clamp(16px, 2vw, 30px); 
    height: clamp(16px, 2vw, 30px); 
    border-radius: 25%; 
    border: none; 
    background-color: rgba(39,86,211,0.92); 
    color: #ffffff; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    cursor: pointer; 
    transition: transform .16s ease, box-shadow .18s ease, background-color .18s ease; 
    z-index: 12; 
    flex-shrink: 0; 
}

.viz-download-button:hover { 
    transform: translateY(-1px); 
    background-color: #7573d2; 
}

.viz-download-button:active { 
    transform: translateY(0); 
    background-color: rgba(39,86,211,0.85); 
}

.viz-download-button:disabled { 
    opacity: 0.7; 
    cursor: wait; 
    transform: none; 
}

.viz-download-button:focus-visible { 
    outline: 2px solid rgba(39,86,211,0.4); 
    outline-offset: 3px; 
}

.viz-download-button img { 
    width: 88%; 
    height: 88%; 
    pointer-events: none; 
    filter: brightness(0) invert(1); 
}

body.slider-hidden .viz-grid { 
  --row-chart: 20fr; 
  --row-slider: 0fr; 
}

body.slider-hidden #container2 { 
  display: none; 
}
#containerTitle { 
    grid-row: 1; 
    grid-column: 1 / span 2; 
    display: flex; 
    align-items: flex-end; 
    justify-content: flex-start; 
    padding: clamp(8px, 2vh, 16px) clamp(16px, 3vw, 32px); 
}
.viz-title-block { 
    display: flex; 
    flex-direction: column; 
    gap: clamp(4px, 0.8vh, 10px); 
    width: 100%;
    max-width: 100%;
}
.viz-main-title { 
    font-size: clamp(20px, 3vw, 34px); 
    font-weight: 700; 
    color: var(--viz-title-color, #101a35); 
    text-align: left; 
    line-height: 1.2; 
    margin: 0; 
    max-width: 100%;
}
.viz-subtitle { 
    font-size: clamp(13px, 2vw, 22px); 
    font-weight: 600; 
    color: var(--viz-subtitle-color, #1f2a44); 
    text-align: left; 
    max-width: 100%; 
    line-height: 1.3; 
}
#container1 { 
    grid-row: 2; 
    grid-column: 1 / span 2; 
    display: flex; 
    overflow: hidden; 
    min-height: 0; 
    column-gap: 0; 
    padding: 0 12px;
}
#container1 .y-axis-container { 
    flex: 0 0 clamp(32px, 3vw, 46px); 
    display: flex; 
    align-items: center; 
    justify-content: center;
    min-width: 0;
    border-right: 1px solid var(--viz-divider, rgba(0,0,0,0.1)); 
    box-sizing: border-box; 
    padding: 0 6px; 
}
#container1 .y-axis-label { 
    writing-mode: vertical-rl; 
    transform: rotate(180deg); 
    text-align: center; 
    font-weight: 600; 
    font-size: clamp(11px, 1.2vw, 16px); 
    color: var(--viz-axis-label, #333); 
    line-height: 1.2; 
    letter-spacing: 0.04em; 
}
#container1 .chart-wrapper { 
    flex: 1 1 auto; 
    display: flex; 
    min-width: 0; 
    height: 100%; 
    margin-left: -6px;
}
#container1 .chart-wrapper-inner { 
    flex: 1 1 auto; 
    display: flex; 
    min-width: 0; 
    height: 100%; 
}

#container2 { grid-row: 3; 
    grid-column: 1 / span 2; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    gap: 10px;
    overflow: hidden; 
    font-size: clamp(10px, 1.6vw, 16px); 
    padding: 6px 10px; 
}
.metric-buttons { 
    display: flex; 
    flex-wrap: wrap; 
    align-items: center; 
    justify-content: center; 
    gap: 8px 10px; 
}
.metric-btn { 
    padding: 6px 10px; 
    border-radius: 8px; 
    border: 1px solid var(--viz-divider, #cfd2d7); 
    background: var(--viz-card-bg, #fff); 
    color: var(--viz-body-text, #111); 
    font-weight: 600; 
    cursor: pointer; 
    user-select: none; 
    transition: transform .08s ease, background .12s ease; 
}
.metric-btn:hover { 
    transform: translateY(-1px); 
}
.metric-btn.active { 
    background: #2756d3; 
    color: #fff; 
    border-color: #2756d3; 
}

#container3 { 
    grid-row: 4; 
    grid-column: 1; 
    display: flex; 
    align-items: center; 
    justify-content: flex-start; 
    padding: 0 20px; 
    overflow: hidden; 
    min-width: 0;
}
#container4 { 
    grid-row: 4; 
    grid-column: 2; 
    display: flex; 
    align-items: center; 
    justify-content: flex-end; 
    gap: clamp(10px, 2vw, 16px); 
    padding: 0 20px; 
    overflow: hidden; 
    min-width: 0; 
}
#container4 .logo { 
    flex-shrink: 0; 
}
#container4 a { 
    height: 100%; 
    display: flex; 
    align-items: center; 
}

.source-text { 
    font-size: clamp(10px, 1.6vw, 16px); 
    font-weight: 600; 
    color: var(--viz-source-text, #333); 
    white-space: nowrap; 
    overflow: hidden; 
    text-overflow: ellipsis; 
    max-width: 100%; 
    font-style: normal; 
}
.source-text a { 
    color: var(--viz-link-color, #2756d3); 
    text-decoration: underline; 
    cursor: pointer; 
    font-style: normal; 
}
.source-text a:visited { 
    color: var(--viz-link-color, #2756d3); 
}
.logo { 
    height: 100%; 
    width: auto; 
    max-height: 100%; 
    max-width: 100%; 
    pointer-events: auto; 
    object-fit: contain; 
}

@media (max-height: 500px) {
  .viz-grid { 
    grid-template-rows: 1fr; 
    grid-template-columns: 1fr; 
    padding-bottom: 0; }
  #containerTitle, #container2, #container3, #container4 { display: none !important; }
  #container1 { grid-row: 1; 
    grid-column: 1; }
}

#viz { 
    position: relative; 
    width: 100%; 
    height: 105%; 
    min-width: 0; 
    min-height: 0; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
}
#chart { 
    display: block; 
    width: 100%; 
    height: 95%; 
}
#tooltip { 
    position: absolute; 
    background: var(--viz-tooltip-bg, #fff); 
    border: 1px solid var(--viz-tooltip-border, #d9d9df); 
    border-radius: 6px; 
    padding: 6px 8px; 
    font-size: 12px; 
    color: var(--viz-body-text, #111); 
    pointer-events: none; 
    opacity: 0; 
    box-shadow: 0 4px 14px rgba(0,0,0,0.08); 
    transition: opacity .12s ease; 
}

.axis path, .axis line { stroke: var(--viz-axis-line, #cfd2d7); }
.tick text { font-size: clamp(8px, 0.9vw, 11px); fill: var(--viz-axis-label, #333); }
.grid line { stroke: var(--viz-grid-line, rgba(230,232,239,0.45)); }
.grid .domain { display: none; }
.final-label { 
  font-weight: 600; 
  pointer-events: none; 
}
.year-dividers line { 
  stroke: var(--viz-axis-line, #cfd2d7); 
  stroke-width: 1; 
}
.year-dividers text { 
  fill: var(--viz-muted-text, #6e7485); 
  font-weight: 600; 
  pointer-events: none; 
  letter-spacing: 0.01em; 
}
</style>

</head>
<body>
<div class="viz-layout" id="vizLayout">
  <div class="viz-grid">
    <div id="containerTitle" class="container title-container">
      <div class="viz-title-block">
        <h1 id="vizMainTitle" class="viz-main-title">Global Leaders in Open-Source AI</h1>
        <div id="vizSubtitle" class="viz-subtitle">Loading data…</div>
      </div>
    </div>
    <div id="container1" class="container chart-container">
      <div class="y-axis-container">
        <div class="y-axis-label" id="yLabel">Cumulative value</div>
      </div>
      <div class="chart-wrapper">
        <div class="chart-wrapper-inner">
          <div id="viz">
            <svg id="chart"></svg>
            <div id="tooltip"></div>
          </div>
        </div>
      </div>
    </div>
    <div id="container2" class="container legend-container"></div>
    <div id="container3" class="container source-container">
      <div class="source-text">Source: <a href="https://huggingface.co/" target="_blank" rel="noopener">HuggingFace</a></div>
    </div>
    <div id="container4" class="container logo-container">
      <a href="https://aiworld.eu/" target="_blank" rel="noopener">
        <img src="logo.svg" class="logo" alt="AI World logo" crossorigin="anonymous">
      </a>
    </div>
  </div>
</div>

<script id="vizScript">
const svg=d3.select("#chart");
const tooltip=d3.select("#tooltip");
const legendEl=d3.select("#legend");
const yLabelEl=document.getElementById("yLabel");
const titleContainer=document.getElementById("containerTitle");
const subtitleEl=document.getElementById("vizSubtitle");
const vizLayout=document.getElementById("vizLayout");
const downloadButton=document.getElementById("downloadButton");
const colorScale=d3.scaleOrdinal(d3.schemeTableau10);
const orgMeta=new Map();
const INLINE_EXPORT=window.__INLINE_EXPORT__||null;
const IS_EXPORT_MODE=!!(INLINE_EXPORT&&INLINE_EXPORT.exportMode);
const INLINE_DATA=INLINE_EXPORT&&Array.isArray(INLINE_EXPORT.data)?INLINE_EXPORT.data:null;
const INLINE_ORGS=INLINE_EXPORT&&Array.isArray(INLINE_EXPORT.orgs)?INLINE_EXPORT.orgs:null;
const INLINE_STATE=INLINE_EXPORT&&INLINE_EXPORT.state&&typeof INLINE_EXPORT.state==="object"?INLINE_EXPORT.state:null;
let inlineActiveIdSet=INLINE_STATE&&Array.isArray(INLINE_STATE.activeIds)?new Set(INLINE_STATE.activeIds):null;
const SCREENSHOT_TARGET_SELECTOR=".viz-grid";
const HTML2CANVAS_SRC="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js";
let html2canvasLoadingPromise=null;
const LOGO_PRELOADS=new Map();
const MONTH_LABELS=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
function getMonthLabel(month){
  if(Number.isInteger(month)&&month>=0&&month<MONTH_LABELS.length){ return MONTH_LABELS[month]; }
  if(Number.isFinite(month)){ return `M${month+1}`; }
  return "M";
}
const METRICS=[
  {key:"repos_total",weekKey:"repos_week",label:"Repos"},
  {key:"likes_total",weekKey:"likes_week",label:"Likes"},
  {key:"downloads_total",weekKey:"downloads_week",label:"Downloads"},
  {key:"spaces_total",weekKey:"spaces_week",label:"Spaces"},
  {key:"datasets_total",weekKey:"datasets_week",label:"Datasets"},
  {key:"models_total",weekKey:"models_week",label:"Models"}
];
const MIN_SPACES_OPTIONS=[10];
const MIN_DOWNLOAD_OPTIONS=[250,500,1000];
const DATA_BASE_PATH="./data";
const DATA_FILE_PREFIX="org_weeks_";
const DATA_FILE_SUFFIX=".json";
const dataCache=new Map();
let currentMetric="repos_total";
let currentMode="cumulative";
let currentPeriod="weekly";
let currentScale="absolute";
let currentNormMode="againstStart";
let lastAbsoluteMode="cumulative";
let rawById=[];
let series=[];
let currentTimeline=[];
let active=new Map();
let currentRange={startIndex:0,endIndex:0};
let rangeDirty=false;
let sliderPanelEl=null;
let sliderInitialized=false;
let sliderVisible=true;
let titleVisible=true;
let legendFullIds=[];
let legendCurrentIds=[];
let currentFilter={ percent:100, metric:METRICS.length?METRICS[0].key:null };
let currentOrgFilter="companies";
let currentRegionFilter="all";
let currentTheme="dark";
let suppressAnimationNextRender=false;
let currentMinSpaces=MIN_SPACES_OPTIONS[0];
let currentMinDownloads=MIN_DOWNLOAD_OPTIONS[0];
let dataLoadToken=0;
let orgListPromise=null;

function isTransparentColor(color){
  if(!color){ return true; }
  const normalized=color.trim().toLowerCase();
  if(!normalized||normalized==="transparent"){ return true; }
  const match=normalized.match(/rgba?\(([^)]+)\)/i);
  if(!match){ return false; }
  const parts=match[1].split(",").map(part=>part.trim());
  if(parts.length<4){ return false; }
  const alpha=parseFloat(parts[3]);
  return !Number.isFinite(alpha)||alpha===0;
}

function resolveBackgroundColor(element){
  let current=element;
  while(current){
    const color=window.getComputedStyle(current).backgroundColor;
    if(!isTransparentColor(color)){ return color; }
    current=current.parentElement;
  }
  const bodyColor=window.getComputedStyle(document.body).backgroundColor;
  return isTransparentColor(bodyColor)?getCssVar("--viz-body-bg","#ffffff"):bodyColor;
}

function getCssVar(name,fallback=""){
  if(!name){ return fallback; }
  try{
    const value=getComputedStyle(document.documentElement).getPropertyValue(name);
    if(value&&value.trim()){ return value.trim(); }
  }catch(err){}
  return fallback;
}

function preloadLogo(url){
  if(!url){ return null; }
  const existing=LOGO_PRELOADS.get(url);
  if(existing){ return existing.promise; }
  const img=new Image();
  img.crossOrigin="anonymous";
  const promise=new Promise(resolve=>{
    img.onload=()=>resolve(true);
    img.onerror=()=>resolve(false);
  });
  LOGO_PRELOADS.set(url,{ promise, image:img });
  img.src=url;
  return promise;
}

function getPreloadedLogo(url){
  if(!url){ return null; }
  const entry=LOGO_PRELOADS.get(url);
  if(!entry){ return null; }
  const { image }=entry;
  if(image&&image.complete){ return image; }
  return null;
}

function normalizeThresholdOption(value, options, fallback){
  if(!Array.isArray(options)||!options.length){
    return Number.isFinite(fallback)?fallback:null;
  }
  const numeric=Number(value);
  if(Number.isFinite(numeric)&&options.includes(numeric)){
    return numeric;
  }
  if(Number.isFinite(fallback)&&options.includes(fallback)){
    return fallback;
  }
  return options[0];
}

function normalizeMinSpaces(value){
  return normalizeThresholdOption(value,MIN_SPACES_OPTIONS,MIN_SPACES_OPTIONS[0]);
}

function normalizeMinDownloads(value){
  return normalizeThresholdOption(value,MIN_DOWNLOAD_OPTIONS,MIN_DOWNLOAD_OPTIONS[0]);
}

function buildDataKey(minSpaces,minDownloads){
  return `${minSpaces}_${minDownloads}`;
}

function buildDataUrl(minSpaces,minDownloads){
  const thresholdKey=buildDataKey(minSpaces,minDownloads);
  return `${DATA_BASE_PATH}/${DATA_FILE_PREFIX}${thresholdKey}${DATA_FILE_SUFFIX}`;
}

if(INLINE_STATE){
  if(typeof INLINE_STATE.currentMetric==="string"){ currentMetric=INLINE_STATE.currentMetric; }
  if(typeof INLINE_STATE.currentMode==="string"){ currentMode=INLINE_STATE.currentMode; }
  if(typeof INLINE_STATE.currentPeriod==="string"){ currentPeriod=INLINE_STATE.currentPeriod; }
  if(typeof INLINE_STATE.currentScale==="string"){ currentScale=INLINE_STATE.currentScale; }
  if(typeof INLINE_STATE.currentNormMode==="string"){ currentNormMode=INLINE_STATE.currentNormMode; }
  if(typeof INLINE_STATE.lastAbsoluteMode==="string"){ lastAbsoluteMode=INLINE_STATE.lastAbsoluteMode; }
  if(typeof INLINE_STATE.sliderVisible==="boolean"){ sliderVisible=INLINE_STATE.sliderVisible; }
  if(typeof INLINE_STATE.titleVisible==="boolean"){ titleVisible=INLINE_STATE.titleVisible; }
  if(INLINE_STATE.currentFilter&&typeof INLINE_STATE.currentFilter==="object"){
    const percent=clampFilterPercent(INLINE_STATE.currentFilter.percent);
    const metricKey=typeof INLINE_STATE.currentFilter.metric==="string"?INLINE_STATE.currentFilter.metric:null;
    currentFilter={ percent, metric:metricKey };
  }
  if(typeof INLINE_STATE.currentOrgFilter==="string"){ currentOrgFilter=normalizeOrgFilter(INLINE_STATE.currentOrgFilter); }
  if(typeof INLINE_STATE.currentRegionFilter==="string"){ currentRegionFilter=normalizeRegionFilter(INLINE_STATE.currentRegionFilter); }
  if(Number.isFinite(INLINE_STATE.currentMinSpaces)){ currentMinSpaces=normalizeMinSpaces(INLINE_STATE.currentMinSpaces); }
  if(Number.isFinite(INLINE_STATE.currentMinDownloads)){ currentMinDownloads=normalizeMinDownloads(INLINE_STATE.currentMinDownloads); }
  if(typeof INLINE_STATE.theme==="string"){ currentTheme=INLINE_STATE.theme==="dark"?"dark":"light"; }
  if(Number.isFinite(INLINE_STATE.rangeStart)||Number.isFinite(INLINE_STATE.rangeEnd)){
    const start=Number.isFinite(INLINE_STATE.rangeStart)?INLINE_STATE.rangeStart:0;
    const end=Number.isFinite(INLINE_STATE.rangeEnd)?INLINE_STATE.rangeEnd:INLINE_STATE.rangeStart;
    currentRange={ startIndex:start, endIndex:end };
    rangeDirty=true;
    suppressAnimationNextRender=true;
  }
  if(INLINE_STATE.rangeDirty===true){
    rangeDirty=true;
  }
}

function capitalizeFirst(text){
  if(typeof text!=="string"||!text.length){ return text||""; }
  return text.charAt(0).toUpperCase()+text.slice(1);
}

function getPeriodDisplayLabel(){
  switch(currentPeriod){
    case "monthly": return "Monthly data";
    case "yearly": return "Yearly data";
    default: return "Weekly data";
  }
}

function getScaleDescriptor(){
  if(currentScale==="normalized"){
    return currentNormMode==="againstPrevious"?"Indexed to previous period":"Indexed to start period";
  }
  if(currentScale==="log"){
    return "Log scale";
  }
  return "Absolute values";
}

function getModeDescriptor(){
  if(currentScale==="normalized"){ return null; }
  if(currentMode==="perWeek"){ return `Per ${getPeriodLabel()}`; }
  return "Cumulative totals";
}

function getActiveIds(){
  const ids=rawById.map(s=>s.id);
  return ids.filter(id=>active.get(id)!==false);
}

function formatOrgSummary(){
  const allIds=rawById.map(s=>s.id);
  if(!allIds.length){ return ""; }
  const activeIds=getActiveIds();
  if(!activeIds.length){ return "No organizations selected"; }
  if(activeIds.length===allIds.length){
    return `All ${allIds.length} organizations`;
  }
  const shown=activeIds.slice(0,3);
  const remaining=activeIds.length-shown.length;
  return remaining>0?`${shown.join(", ")} (+${remaining} more)`:shown.join(", ");
}

function formatTitleDate(info){
  if(!info){ return ""; }
  const label=info.label||`Period ${info.coord??""}`;
  return stripTimePrefix(label);
}

function formatRangeText(timelineSlice){
  if(!currentTimeline.length){ return { text:"No data", coversAll:false, startLabel:"", endLabel:"" }; }
  const {startIndex,endIndex}=getClampedRangeIndices();
  const fallback=currentTimeline.slice(startIndex,Math.min(endIndex+1,currentTimeline.length));
  const slice=(timelineSlice&&timelineSlice.length)?timelineSlice:fallback;
  if(!slice.length){ return { text:"No data", coversAll:false, startLabel:"", endLabel:"" }; }
  const startInfo=slice[0];
  const endInfo=slice[slice.length-1];
  const startLabel=formatTitleDate(startInfo);
  const endLabel=formatTitleDate(endInfo);
  const coversAll=startIndex===0&&endIndex===currentTimeline.length-1;
  let text="";
  if(startLabel===endLabel){
    text=startLabel;
  }else{
    text=`${startLabel} – ${endLabel}`;
  }
  return { text, coversAll, startLabel, endLabel };
}

function updateTitle(timelineSlice){
  if(!subtitleEl){ return; }
  if(!rawById.length||!currentTimeline.length){
    subtitleEl.textContent="No data available";
    return;
  }
  const metricDef=getMetricDefinition();
  const metricLabel=metricDef?metricDef.label:"Metric";
  const periodWord=getPeriodAdjective();
  let subjectText=metricLabel;
  if(currentScale!=="normalized"){
    if(currentMode==="perWeek"){
      subjectText=`${metricLabel} per ${getPeriodLabel()}`;
    }else if(currentMode==="cumulative"){
      const prefix=periodWord?`${capitalizeFirst(periodWord)} `:"";
      subjectText=`${prefix}cumulative ${metricLabel}`;
    }else if(periodWord){
      subjectText=`${capitalizeFirst(periodWord)} ${metricLabel}`;
    }
  }else if(periodWord){
    subjectText=`${capitalizeFirst(periodWord)} ${metricLabel}`;
  }
  if(!subjectText){ subjectText=metricLabel; }
  let sentence=`${subjectText}`;
  if(currentScale==="normalized"){
    sentence+=currentNormMode==="againstPrevious"?" indexed to the previous period":" indexed to the starting period";
  }else if(currentScale==="log"){
    sentence+=" on a log scale";
  }else{
    sentence+=" in absolute values";
  }
  const rangeSummary=formatRangeText(timelineSlice);
  //if(rangeSummary&&rangeSummary.text){ sentence+=` from ${rangeSummary.text}`; }
  sentence = "Cumulative number of Hugging Face repositories in 2025";
  //if(rangeSummary&&rangeSummary.coversAll){ sentence+=" (full timeline)"; }
  subtitleEl.textContent=sentence;
}

function getOrgInfo(id){
  return orgMeta.get(id)||null;
}

function getSeriesColor(id){
  const info=getOrgInfo(id);
  if(info&&info.color){ return info.color; }
  return colorScale(id);
}

function sanitizeForId(value){
  return String(value||"").toLowerCase().replace(/[^a-z0-9]+/g,"-");
}

function ensureLogoPattern(id,logoUrl){
  if(!logoUrl){ return null; }
  const sanitized=sanitizeForId(id);
  const patternId=`logo-pattern-${sanitized}`;
  const defs=svg.selectAll("defs.logo-patterns").data([null]).join("defs").attr("class","logo-patterns");
  const pattern=defs.selectAll(`pattern#${patternId}`).data([logoUrl]).join(
    enter=>{
      const p=enter.append("pattern").attr("id",patternId).attr("patternUnits","objectBoundingBox").attr("patternContentUnits","objectBoundingBox").attr("width",1).attr("height",1);
      p.append("image").attr("href",logoUrl).attr("xlink:href",logoUrl).attr("width",1).attr("height",1).attr("preserveAspectRatio","xMidYMid slice").attr("crossorigin","anonymous");
      return p;
    },
    update=>update
  );
  pattern.select("image").attr("href",logoUrl).attr("xlink:href",logoUrl).attr("crossorigin","anonymous");
  return patternId;
}

function arraysEqual(a,b){
  if(a===b){ return true; }
  if(!Array.isArray(a)||!Array.isArray(b)||a.length!==b.length){ return false; }
  for(let i=0;i<a.length;i++){
    if(a[i]!==b[i]){ return false; }
  }
  return true;
}

function clampFilterPercent(value){
  const num=Number(value);
  if(!Number.isFinite(num)){ return 100; }
  if(num<0){ return 0; }
  if(num>100){ return 100; }
  return num;
}

function getFilterLimitCount(percent,totalCount){
  const total=Math.max(0,totalCount|0);
  const normalized=clampFilterPercent(percent);
  if(!total){ return 0; }
  if(normalized>=100){ return null; }
  const count=Math.ceil(total*normalized/100);
  return Math.max(0,Math.min(count,total));
}

function normalizeOrgFilter(value){
  const text=String(value??"").trim().toLowerCase();
  if(text==="companies"||text==="company"){ return "companies"; }
  if(text==="noncompanies"||text==="non-companies"||text==="noncompany"){ return "noncompanies"; }
  return "all";
}

function matchesOrgFilter(id){
  if(!id){ return false; }
  if(currentOrgFilter==="all"){ return true; }
  const info=getOrgInfo(id);
  const isCompany=info?info.company===true:false;
  if(currentOrgFilter==="companies"){ return isCompany; }
  if(currentOrgFilter==="noncompanies"){ return !isCompany; }
  return true;
}

function normalizeRegionKey(value){
  const text=String(value??"").trim().toLowerCase();
  if(text==="north america"||text==="north-america"||text==="na"){ return "north-america"; }
  if(text==="europe"){ return "europe"; }
  if(text==="china"){ return "china"; }
  return text||null;
}

function normalizeRegionFilter(value){
  const text=String(value??"").trim().toLowerCase();
  if(text==="north america"||text==="north-america"||text==="na"){ return "north-america"; }
  if(text==="europe"){ return "europe"; }
  if(text==="china"){ return "china"; }
  return "all";
}

function normalizeTheme(value){
  return value==="dark"?"dark":"light";
}

function matchesRegionFilter(id){
  if(currentRegionFilter==="all"){ return true; }
  const info=getOrgInfo(id);
  if(!info){ return false; }
  return info.regionKey===currentRegionFilter;
}

function matchesAllFilters(id){
  return matchesOrgFilter(id)&&matchesRegionFilter(id);
}

function filterSeriesByOrg(seriesData){
  if(!Array.isArray(seriesData)){ return []; }
  return seriesData.filter(entry=>matchesAllFilters(entry&&entry.id));
}

function updateLegendIds(){
  const filteredIds=rawById.map(({id})=>id).filter(matchesAllFilters);
  legendFullIds=filteredIds;
  rawById.forEach(({id})=>{
    if(matchesAllFilters(id)){
      active.set(id,true);
    }else{
      active.set(id,false);
    }
  });
  if(!arraysEqual(legendCurrentIds,filteredIds)){
    buildLegend(filteredIds);
  }else{
    refreshLegendState();
  }
}

function setOrgFilter(filter,options={}){
  const next=normalizeOrgFilter(filter);
  if(next===currentOrgFilter&&!options.force){ return; }
  currentOrgFilter=next;
  updateLegendIds();
  if(!options.skipConfig&&window.ConfigTab&&typeof window.ConfigTab.setOrgFilter==="function"){
    window.ConfigTab.setOrgFilter(currentOrgFilter);
  }
  if(!options.skipRender){
    render();
  }
}

function setRegionFilter(filter,options={}){
  const next=normalizeRegionFilter(filter);
  if(next===currentRegionFilter&&!options.force){ return; }
  currentRegionFilter=next;
  updateLegendIds();
  if(!options.skipConfig&&window.ConfigTab&&typeof window.ConfigTab.setRegionFilter==="function"){
    window.ConfigTab.setRegionFilter(currentRegionFilter);
  }
  if(!options.skipRender){
    render();
  }
}

function setMinSpaces(value,options={}){
  const next=normalizeMinSpaces(value);
  if(next===currentMinSpaces&&!options.force){ return; }
  currentMinSpaces=next;
  if(!options.skipConfig&&window.ConfigTab&&typeof window.ConfigTab.setMinSpaces==="function"){
    window.ConfigTab.setMinSpaces(currentMinSpaces);
  }
  if(!options.skipLoad){
    load();
  }
}

function setMinDownloads(value,options={}){
  const next=normalizeMinDownloads(value);
  if(next===currentMinDownloads&&!options.force){ return; }
  currentMinDownloads=next;
  if(!options.skipConfig&&window.ConfigTab&&typeof window.ConfigTab.setMinDownloads==="function"){
    window.ConfigTab.setMinDownloads(currentMinDownloads);
  }
  if(!options.skipLoad){
    load();
  }
}

function computeTopIdsFromScores(limitCount,scoresMap){
  if(limitCount===null){ return legendFullIds.slice(); }
  if(!Number.isFinite(limitCount)||limitCount<=0){ return []; }
  const entries=Array.from(scoresMap.entries()).map(([id,score])=>({ id, score:Number.isFinite(score)?score:-Infinity }));
  entries.sort((a,b)=>{
    if(b.score===a.score){
      return a.id.localeCompare(b.id);
    }
    return (b.score??-Infinity)-(a.score??-Infinity);
  });
  return entries.slice(0,Math.min(limitCount,entries.length)).map(entry=>entry.id);
}

function buildSeriesForMetric(metricKey){
  if(!metricKey||!currentTimeline.length){ return []; }
  const period=currentPeriod;
  const isPerPeriod=currentMode==="perWeek";
  return rawById.filter(({id})=>matchesAllFilters(id)).map(({id, values})=>{
    const aggregated=new Map();
    values.forEach(entry=>{
      const info=getPeriodInfo(entry,period);
      if(!info){ return; }
      const target=aggregated.get(info.order)||{sum:0,last:null};
      const metricValue=+entry[metricKey]||0;
      if(isPerPeriod){
        target.sum+=metricValue;
      }else{
        target.last=metricValue;
      }
      aggregated.set(info.order,target);
    });
    const result=[];
    let running=0;
    currentTimeline.forEach(info=>{
      const dataPoint=aggregated.get(info.order);
      let rawValue=0;
      let endValue=running;
      if(isPerPeriod){
        rawValue=dataPoint?dataPoint.sum:0;
        endValue=rawValue;
      }else{
        if(currentMode==="cumulative"){
          rawValue=running;
          if(dataPoint&&typeof dataPoint.last==="number"){
            running=dataPoint.last;
          }
          endValue=running;
        }else{
          if(dataPoint&&typeof dataPoint.last==="number"){
            running=dataPoint.last;
          }
          rawValue=running;
          endValue=running;
        }
      }
      result.push({
        w:info.coord,
        rawValue,
        value:rawValue,
        endValue,
        label:info.label,
        actualLabel:info.label,
        relativeLabel:null,
        order:info.order,
        date:info.date,
        relativeIndex:info.relativeIndex,
        absoluteIndex:info.absoluteIndex
      });
    });
    return { id, values:result };
  });
}

function transformSeriesForRange(seriesData,startIndex,endIndex){
  return seriesData.map(s=>{
    const slice=s.values.filter(v=>v.relativeIndex>=startIndex&&v.relativeIndex<=endIndex);
    if(!slice.length){ return { id:s.id, values:[] }; }
    if(currentScale==="normalized"){
      if(currentNormMode==="againstPrevious"){
        const values=normalizeAgainstPrevious(slice);
        return { id:s.id, values };
      }
      const values=normalizeAgainstStart(slice);
      return { id:s.id, values };
    }
    if(currentMode==="cumulative"){
      const baseRaw=slice.length? (Number.isFinite(slice[0].rawValue)?slice[0].rawValue:0):0;
      const baseEnd=slice.length? (Number.isFinite(slice[0].endValue)?slice[0].endValue:baseRaw):baseRaw;
      const values=slice.map(v=>{
        const startValue=v.rawValue-baseRaw;
        const endValue=(Number.isFinite(v.endValue)?v.endValue:(Number.isFinite(v.rawValue)?v.rawValue:0))-baseEnd;
        return { ...v, value:startValue, startValue, displayEndValue:endValue };
      });
      return { id:s.id, values };
    }
    const adjusted=slice.map(v=>{
      const displayEnd=Number.isFinite(v.endValue)?v.endValue:(Number.isFinite(v.value)?v.value:0);
      return { ...v, displayEndValue:displayEnd };
    });
    return { id:s.id, values:adjusted };
  });
}

function computeScoresFromSeries(seriesData){
  const scores=new Map();
  seriesData.forEach(s=>{
    const values=s.values;
    const last=values&&values.length?values[values.length-1]:null;
    let score=-Infinity;
    if(last){
      if(Number.isFinite(last.displayEndValue)){
        score=last.displayEndValue;
      }else if(Number.isFinite(last.value)){
        score=last.value;
      }
    }
    scores.set(s.id,score);
  });
  return scores;
}

function computeDownloadsPerRepoScores(startIndex,endIndex){
  const downloadsSeries=filterSeriesByOrg(transformSeriesForRange(buildSeriesForMetric("downloads_total"),startIndex,endIndex));
  const reposSeries=filterSeriesByOrg(transformSeriesForRange(buildSeriesForMetric("repos_total"),startIndex,endIndex));
  const repoScores=new Map();
  reposSeries.forEach(s=>{
    const values=s.values;
    const last=values&&values.length?values[values.length-1]:null;
    const value=last&&Number.isFinite(last.displayEndValue)?last.displayEndValue:(last&&Number.isFinite(last.value)?last.value:0);
    repoScores.set(s.id,value);
  });
  const scores=new Map();
  downloadsSeries.forEach(s=>{
    const values=s.values;
    const last=values&&values.length?values[values.length-1]:null;
    const downloads=last&&Number.isFinite(last.displayEndValue)?last.displayEndValue:(last&&Number.isFinite(last.value)?last.value:0);
    const repos=repoScores.has(s.id)?repoScores.get(s.id):0;
    const safeRepos=Math.abs(repos)>1e-9?repos:1;
    const ratio=downloads/safeRepos;
    scores.set(s.id,Number.isFinite(ratio)?ratio:0);
  });
  reposSeries.forEach(s=>{
    if(scores.has(s.id)){ return; }
    const repos=repoScores.get(s.id)||0;
    const safeRepos=Math.abs(repos)>1e-9?repos:1;
    scores.set(s.id,0/safeRepos);
  });
  legendFullIds.forEach(id=>{
    if(!scores.has(id)){ scores.set(id,0); }
  });
  return scores;
}

function parseDateYYYYMMDD(s){
  if(typeof s!=="string"||!s){ return null; }
  const m=s.match(/^(\d{4})-(\d{2})-(\d{2})/);
  if(!m){ return null; }
  const y=+m[1];
  const mo=+m[2]-1;
  const d=+m[3];
  return new Date(Date.UTC(y,mo,d));
}

function formatValue(v){
  if(!Number.isFinite(v)){ return "0"; }
  if(currentScale==="normalized"){ return d3.format(".2~f")(v); }
  return d3.format(",")(v);
}

function formatRawValue(v){
  if(!Number.isFinite(v)){ return "0"; }
  return d3.format(",")(v);
}

function getPeriodLabel(){
  switch(currentPeriod){
    case "monthly": return "month";
    case "yearly": return "year";
    default: return "week";
  }
}

function getPeriodAdjective(){
  switch(currentPeriod){
    case "monthly": return "monthly";
    case "yearly": return "yearly";
    default: return "weekly";
  }
}

function getMetricDefinition(){
  return METRICS.find(m=>m.key===currentMetric)||METRICS[0];
}

function getActiveMetricKey(){
  const def=getMetricDefinition();
  return currentMode==="perWeek"&&def.weekKey?def.weekKey:def.key;
}

function getModeSuffix(){
  return currentMode==="perWeek"?`(per ${getPeriodLabel()})`:"(total)";
}

function getScaleSuffix(){
  if(currentScale==="normalized"){
    if(currentNormMode==="againstPrevious"){ return " (indexed to previous=1)"; }
    return " (indexed to start=1)";
  }
  if(currentScale==="log"){ return " (log scale)"; }
  return "";
}

function addDays(date,days){
  if(!date){ return null; }
  const next=new Date(date.getTime());
  next.setUTCDate(next.getUTCDate()+days);
  return next;
}

function formatWeekLabel(date){
  if(!date){ return "Week"; }
  const month=getMonthLabel(date.getUTCMonth());
  const day=date.getUTCDate();
  const year=date.getUTCFullYear();
  return `Week of ${month} ${day}, ${year}`;
}

function formatMonthLabel(date){
  if(!date){ return "Month"; }
  const month=getMonthLabel(date.getUTCMonth());
  const year=date.getUTCFullYear();
  return `Month of ${month} ${year}`;
}

function stripTimePrefix(label){
  if(typeof label!=="string"){ return label; }
  return label.replace(/^(Week|Month)\s+of\s+/i,"");
}

function getRelativePeriodLabel(index){
  const unit=currentPeriod==="monthly"?"Month":currentPeriod==="yearly"?"Year":"Week";
  return `${unit} ${index}`;
}

function orderToYearMonth(order){
  const year=Math.floor(order/12);
  const month=order-year*12;
  return { year, month };
}

function getPeriodInfo(entry, period){
  if(!entry){ return null; }
  if(period==="monthly"){
    const date=entry.__monthDate||entry.__date||null;
    const year=date?date.getUTCFullYear():Number.isFinite(+entry.year)?+entry.year:NaN;
    if(!Number.isFinite(year)){ return null; }
    const month=date?date.getUTCMonth():Number.isFinite(+entry.month)?(+entry.month-1):NaN;
    const order=year*12+month;
    const label=date?formatMonthLabel(date):`${getMonthLabel(month)} ${year}`;
    return { order, label, date:date||new Date(Date.UTC(year,month,1)), year, month };
  }
  if(period==="yearly"){
    const year=Number.isFinite(+entry.year)?+entry.year:NaN;
    if(!Number.isFinite(year)){ return null; }
    return { order:year, label:`${year}`, date:new Date(Date.UTC(year,0,1)), year, month:null };
  }
  const weekCount=Number.isFinite(+entry.week_count)?+entry.week_count:NaN;
  if(!Number.isFinite(weekCount)){ return null; }
  const date=entry.__weekDate||entry.__date||null;
  const label=date?formatWeekLabel(date):`Week ${weekCount}`;
  return { order:weekCount, label, date:date, year:date?date.getUTCFullYear():Number.isFinite(+entry.year)?+entry.year:undefined, month:date?date.getUTCMonth():undefined };
}

function createInfoFromOrder(order, period, baseInfo){
  if(period==="monthly"){
    const {year, month}=orderToYearMonth(order);
    const date=new Date(Date.UTC(year,month,1));
    return { order, label:formatMonthLabel(date), date, year, month };
  }
  if(period==="yearly"){
    const year=order;
    return { order, label:`${year}`, date:new Date(Date.UTC(year,0,1)), year, month:null };
  }
  let date=null;
  if(baseInfo&&baseInfo.date&&Number.isFinite(baseInfo.order)){
    const diff=order-baseInfo.order;
    date=addDays(baseInfo.date,diff*7);
  }
  return { order, label:date?formatWeekLabel(date):`Week ${order}`, date:date, year:date?date.getUTCFullYear():undefined, month:date?date.getUTCMonth():undefined };
}

function updateAxisLabel(){
  const def=getMetricDefinition();
  if(!def){ return; }
  const descriptors=[];
  if(currentScale!=="normalized"){ descriptors.push(getModeSuffix()); }
  const scaleSuffix=getScaleSuffix();
  if(scaleSuffix){ descriptors.push(scaleSuffix); }
  const descriptorText=descriptors.join(" ").trim();
  const textParts=[def.label];
  if(descriptorText){ textParts.push(descriptorText); }
  const labelText=textParts.join(" ");
  yLabelEl.textContent=labelText;
}

function buildLegend(ids){
  const list=Array.isArray(ids)?ids.slice():[];
  list.forEach(id=>{ if(!active.has(id)){ active.set(id,true); } });
  legendCurrentIds=list.slice();
  if(legendEl.empty()){ return; }
  legendEl.selectAll("*").remove();
  const items=legendEl.selectAll(".legend-item").data(list,d=>d).enter().append("div").attr("class","legend-item").attr("role","button").attr("tabindex",0).attr("aria-pressed","true");
  items.append("div").attr("class","legend-square").style("background",d=>getSeriesColor(d));
  items.append("span").text(d=>d);
  function toggle(_,id){
    const curr=active.get(id);
    active.set(id,!curr);
    d3.select(this).classed("dim",!active.get(id)).attr("aria-pressed",active.get(id)?"true":"false");
    render();
  }
  items.on("click",toggle).on("keydown",function(e,id){ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); toggle.call(this,e,id); } });
  refreshLegendState();
}

function refreshLegendState(){
  if(legendEl.empty()){ return; }
  legendEl.selectAll(".legend-item").attr("aria-pressed",d=>active.get(d)?"true":"false").classed("dim",d=>!active.get(d));
}

function onConfigModeChange(mode){
  if(!mode||mode===currentMode||currentScale==="normalized"){ return; }
  lastAbsoluteMode=mode;
  currentMode=mode;
  if(window.ConfigTab&&typeof window.ConfigTab.setMode==="function"){ window.ConfigTab.setMode(currentMode); }
  updateAxisLabel();
  buildSeriesFromRaw();
  render();
}

function onConfigMetricChange(metric){
  if(!metric||metric===currentMetric){ return; }
  currentMetric=metric;
  if(window.ConfigTab&&typeof window.ConfigTab.setMetric==="function"){ window.ConfigTab.setMetric(currentMetric); }
  updateAxisLabel();
  buildSeriesFromRaw();
  render();
}

function onConfigPeriodChange(period){
  if(!period||period===currentPeriod){ return; }
  currentPeriod=period;
  if(window.ConfigTab&&typeof window.ConfigTab.setPeriod==="function"){ window.ConfigTab.setPeriod(currentPeriod); }
  updateAxisLabel();
  buildSeriesFromRaw();
  render();
}

function onConfigScaleChange(scale){
  if(!scale||scale===currentScale){ return; }
  const previousScale=currentScale;
  currentScale=scale;
  if(currentScale==="normalized"){
    lastAbsoluteMode=currentMode;
    currentMode="cumulative";
    if(window.ConfigTab&&typeof window.ConfigTab.setMode==="function"){ window.ConfigTab.setMode(currentMode); }
    if(window.ConfigTab&&typeof window.ConfigTab.setModeDisabled==="function"){ window.ConfigTab.setModeDisabled(true); }
    if(window.ConfigTab&&typeof window.ConfigTab.setNormModeVisible==="function"){ window.ConfigTab.setNormModeVisible(true); }
  }else{
    if(window.ConfigTab&&typeof window.ConfigTab.setModeDisabled==="function"){ window.ConfigTab.setModeDisabled(false); }
    if(previousScale==="normalized"){
      currentMode=lastAbsoluteMode||currentMode||"cumulative";
      if(window.ConfigTab&&typeof window.ConfigTab.setMode==="function"){ window.ConfigTab.setMode(currentMode); }
    }
    if(window.ConfigTab&&typeof window.ConfigTab.setNormModeVisible==="function"){ window.ConfigTab.setNormModeVisible(false); }
  }
  if(window.ConfigTab&&typeof window.ConfigTab.setScale==="function"){ window.ConfigTab.setScale(currentScale); }
  updateAxisLabel();
  buildSeriesFromRaw();
  render();
}

function onConfigTopFilterChange(filter){
  if(!filter||typeof filter!=="object"){ return; }
  const percent=clampFilterPercent(filter.percent);
  const metricKey=typeof filter.metric==="string"&&filter.metric.trim().length?filter.metric.trim():null;
  const fallbackMetric=currentFilter.metric|| (METRICS.length?METRICS[0].key:null);
  currentFilter={ percent, metric:metricKey||fallbackMetric };
  if(window.ConfigTab&&typeof window.ConfigTab.setTopFilter==="function"){
    window.ConfigTab.setTopFilter(currentFilter);
  }
  render();
}

function onConfigOrgFilterChange(filter){
  setOrgFilter(filter);
}

function onConfigRegionFilterChange(filter){
  setRegionFilter(filter);
}

function onConfigMinSpacesChange(value){
  setMinSpaces(value);
}

function onConfigMinDownloadsChange(value){
  setMinDownloads(value);
}

function onConfigNormModeChange(mode){
  if(!mode||mode===currentNormMode){ return; }
  currentNormMode=mode;
  if(window.ConfigTab&&typeof window.ConfigTab.setNormMode==="function"){ window.ConfigTab.setNormMode(currentNormMode); }
  updateAxisLabel();
  buildSeriesFromRaw();
  render();
}

function getRangeUnit(){
  switch(currentPeriod){
    case "monthly": return "Month";
    case "yearly": return "Year";
    default: return "Week";
  }
}

function formatRangeLabelByIndex(idx){
  if(!Number.isInteger(idx)||idx<0||idx>=currentTimeline.length){ return "N/A"; }
  const info=currentTimeline[idx];
  if(!info){ return "N/A"; }
  return info.label||`Period ${info.coord}`;
}

function getClampedRangeIndices(){
  if(!currentTimeline.length){ return {startIndex:0,endIndex:0,maxIndex:-1}; }
  const maxIndex=currentTimeline.length-1;
  const rawStart=Number.isFinite(currentRange.startIndex)?currentRange.startIndex:0;
  const rawEnd=Number.isFinite(currentRange.endIndex)?currentRange.endIndex:maxIndex;
  const startIndex=Math.max(0,Math.min(rawStart,maxIndex));
  const endIndex=Math.max(startIndex,Math.min(rawEnd,maxIndex));
  return {startIndex,endIndex,maxIndex};
}

function syncRangeWithTimeline(){
  const length=currentTimeline.length;
  if(!length){
    currentRange.startIndex=0;
    currentRange.endIndex=0;
    if(sliderInitialized&&window.RangeSlider&&typeof window.RangeSlider.update==="function"){
      window.RangeSlider.update({ min:0, max:0, start:0, end:0, getLabel:()=> "N/A", unitLabel:getRangeUnit() });
    }
    return;
  }
  const maxIndex=length-1;
  let start=rangeDirty?currentRange.startIndex:0;
  let end=rangeDirty?currentRange.endIndex:52;
  start=Math.max(0,Math.min(Number.isFinite(start)?start:0,maxIndex));
  end=Math.max(start,Math.min(Number.isFinite(end)?end:maxIndex,maxIndex));
  currentRange.startIndex=start;
  currentRange.endIndex=end;
  if(sliderInitialized&&window.RangeSlider&&typeof window.RangeSlider.update==="function"){
    window.RangeSlider.update({ min:0, max:maxIndex, start, end, getLabel:formatRangeLabelByIndex, unitLabel:getRangeUnit() });
  }
}

function handleRangeChange(range){
  if(!range||!currentTimeline.length){ return; }
  if(!sliderVisible){ return; }
  const start=Number.isFinite(range.start)?Math.floor(range.start):0;
  const end=Number.isFinite(range.end)?Math.floor(range.end):0;
  const maxIndex=currentTimeline.length-1;
  const clampedStart=Math.max(0,Math.min(start,maxIndex));
  const clampedEnd=Math.max(clampedStart,Math.min(end,maxIndex));
  if(clampedStart===currentRange.startIndex&&clampedEnd===currentRange.endIndex){ return; }
  rangeDirty=true;
  suppressAnimationNextRender=true;
  currentRange.startIndex=clampedStart;
  currentRange.endIndex=clampedEnd;
  if(tooltip){ tooltip.style("opacity",0); }
  render();
}

function removeDuplicateSliderPanels(){
  const panels=document.querySelectorAll("#sliderPanel");
  if(panels.length>1){ panels.forEach((el,i)=>{ if(i>0){ el.remove(); } }); }
}

function setSliderVisibility(visible,options={}){
  const next=!!visible;
  const previous=sliderVisible;
  sliderVisible=next;
  removeDuplicateSliderPanels();
  const existing=document.getElementById("sliderPanel");
  if(sliderVisible){
    if(existing){
      sliderPanelEl=existing;
      sliderPanelEl.style.display="";
      if(!sliderInitialized&&window.RangeSlider&&typeof window.RangeSlider.init==="function"){
        window.RangeSlider.init({ containerEl: sliderPanelEl, onChange: handleRangeChange });
        sliderInitialized=true;
      }
    }else{
      loadSlider();
    }
  }else{
    if(existing){ existing.style.display="none"; }
  }
  document.body.classList.toggle("slider-hidden",!sliderVisible);
  if(previous!==sliderVisible){
    if(window.ConfigTab&&typeof window.ConfigTab.setSliderVisible==="function"&&!options.skipConfig){ window.ConfigTab.setSliderVisible(sliderVisible); }
    syncRangeWithTimeline();
    render();
  }
}

function setTheme(theme,options={}){
  const next=normalizeTheme(theme);
  const previous=currentTheme;
  currentTheme=next;
  document.body.classList.toggle("theme-dark",next==="dark");
  document.body.dataset.theme=next;
  if(previous!==next){
    document.documentElement.setAttribute("data-theme",next);
    if(!options.skipRender){
      render();
    }
  }
  if(!options.skipConfig&&window.ConfigTab&&typeof window.ConfigTab.setTheme==="function"){
    window.ConfigTab.setTheme(next);
  }
}

function setTitleVisibility(visible,options={}){
  const next=!!visible;
  titleVisible=next;
  if(titleContainer){
    titleContainer.style.display=titleVisible?"":"none";
  }
  if(!options.skipConfig&&window.ConfigTab&&typeof window.ConfigTab.setTitleVisible==="function"){
    window.ConfigTab.setTitleVisible(titleVisible);
  }
}

setTheme(currentTheme,{skipConfig:true,skipRender:true});
setTitleVisibility(titleVisible,{skipConfig:true});
setSliderVisibility(sliderVisible,{skipConfig:true});

async function loadSlider(){
  const container=document.getElementById("container2");
  if(!container){ return; }
  if(document.getElementById("sliderPanel")){
    sliderPanelEl=document.getElementById("sliderPanel");
    sliderPanelEl.style.display=sliderVisible?"":"none";
    if(sliderVisible&&!sliderInitialized&&window.RangeSlider&&typeof window.RangeSlider.init==="function"){
      window.RangeSlider.init({ containerEl: sliderPanelEl, onChange: handleRangeChange });
      sliderInitialized=true;
      syncRangeWithTimeline();
    }
    return;
  }
  try{
    const response=await fetch("./slider.html");
    if(!response.ok){ throw new Error(`HTTP ${response.status}`); }
    const text=await response.text();
    const parser=new DOMParser();
    const doc=parser.parseFromString(text,"text/html");
    if(!document.querySelector('style[data-origin="range-slider"]')){
      const styles=doc.querySelectorAll("style");
      styles.forEach(style=>{ style.dataset.origin="range-slider"; document.head.appendChild(style); });
    }
    const panel=doc.querySelector("#sliderPanel");
    if(panel){
      const legend=document.getElementById("legend");
      if(legend&&legend.parentNode){ legend.parentNode.insertBefore(panel,legend); } else { container.insertBefore(panel,container.firstChild); }
      sliderPanelEl=panel;
      sliderPanelEl.style.display=sliderVisible?"":"none";
    }
    if(!document.querySelector('script[data-origin="range-slider"]')){
      const scripts=doc.querySelectorAll("script");
      scripts.forEach(snippet=>{
        const script=document.createElement("script");
        if(snippet.src){ script.src=snippet.src; } else { script.textContent=snippet.textContent; }
        script.dataset.origin="range-slider";
        document.body.appendChild(script);
      });
    }
    if(sliderVisible&&window.RangeSlider&&typeof window.RangeSlider.init==="function"&&sliderPanelEl){
      window.RangeSlider.init({ containerEl: sliderPanelEl, onChange: handleRangeChange });
      sliderInitialized=true;
      syncRangeWithTimeline();
    }
    removeDuplicateSliderPanels();
  }catch(err){
    console.error("Failed to load slider:",err);
  }
}

function readToggleState(group, attr){
  try{
    if(!group){ return null; }
    const buttons=Array.from(group.querySelectorAll("button"));
    if(!buttons.length){ return null; }
    const showBtn=buttons.find(b=>b.dataset?.[attr]==="show");
    const hideBtn=buttons.find(b=>b.dataset?.[attr]==="hide");
    const showActive=showBtn&&(showBtn.getAttribute("aria-pressed")==="true"||showBtn.classList.contains("active"));
    const hideActive=hideBtn&&(hideBtn.getAttribute("aria-pressed")==="true"||hideBtn.classList.contains("active"));
    if(showActive&&!hideActive){ return true; }
    if(hideActive&&!showActive){ return false; }
  }catch(e){}
  return null;
}

function readTimeSliderStateFromPanel(panel){
  try{
    const group=panel.querySelector("#configSliderButtons");
    const state=readToggleState(group,"slider");
    if(state!==null){ return state; }
  }catch(e){}
  return sliderVisible;
}

function wireConfigSliderBridge(panel){
  try{
    const sliderGroup=panel.querySelector("#configSliderButtons");
    const titleGroup=panel.querySelector("#configTitleButtons");
    const initialSlider=readToggleState(sliderGroup,"slider");
    setSliderVisibility(initialSlider===null?sliderVisible:initialSlider,{skipConfig:true});
    if(sliderGroup){
      sliderGroup.addEventListener("click",function(e){
        const btn=e.target&&e.target.closest(".config-slider-btn");
        if(!btn){ return; }
        const wantsVisible=btn.dataset.slider!=="hide";
        setSliderVisibility(wantsVisible);
      });
    }
    const initialTitle=readToggleState(titleGroup,"title");
    setTitleVisibility(initialTitle===null?titleVisible:initialTitle,{skipConfig:true});
    if(titleGroup){
      titleGroup.addEventListener("click",function(e){
        const btn=e.target&&e.target.closest(".config-title-btn");
        if(!btn){ return; }
        const wantsVisible=btn.dataset.title!=="hide";
        setTitleVisibility(wantsVisible);
      });
    }
    if(window.ConfigTab){
      window.ConfigTab.onSliderVisibleChange=function(visible){ setSliderVisibility(!!visible); };
      window.ConfigTab.onTitleVisibleChange=function(visible){ setTitleVisibility(!!visible); };
    }
    window.setTimelineVisible=function(visible){ setSliderVisibility(!!visible); };
    window.addEventListener("timelineVisibilityChange",function(e){ setSliderVisibility(!!(e&&e.detail)); });
    window.addEventListener("config:timeline",function(e){ setSliderVisibility(!!(e&&e.detail)); });
    window.addEventListener("message",function(e){
      const d=e&&e.data;
      if(d&&d.type==="config:timeline"){ setSliderVisibility(!!d.visible); }
    });
  }catch(e){}
}

async function loadConfigTab(){
  if(!vizLayout){ return; }
  try{
    const response=await fetch("./tab.html");
    if(!response.ok){ throw new Error(`HTTP ${response.status}`); }
    const text=await response.text();
    const parser=new DOMParser();
    const doc=parser.parseFromString(text,"text/html");
    if(!document.querySelector('style[data-origin="config-tab"]')){
      const styles=doc.querySelectorAll("style");
      styles.forEach(style=>{ style.dataset.origin="config-tab"; document.head.appendChild(style); });
    }
    const panel=doc.querySelector("#configPanel");
    if(panel){ vizLayout.appendChild(panel); }
    if(!document.querySelector('script[data-origin="config-tab"]')){
      const scripts=doc.querySelectorAll("script");
      scripts.forEach(snippet=>{
        const script=document.createElement("script");
        if(snippet.src){ script.src=snippet.src; }else{ script.textContent=snippet.textContent; }
        script.dataset.origin="config-tab";
        document.body.appendChild(script);
      });
    }
    if(window.ConfigTab&&typeof window.ConfigTab.init==="function"){
      window.ConfigTab.init({
        panelEl: document.getElementById("configPanel"),
        onThemeChange:setTheme,
        initialTheme: currentTheme,
        initialMode: currentMode,
        initialPeriod: currentPeriod,
        initialScale: currentScale,
        initialNormMode: currentNormMode,
        initialMetric: currentMetric,
        initialSliderVisible: sliderVisible,
        initialTitleVisible: titleVisible,
        initialTopFilter: currentFilter,
        initialOrgFilter: currentOrgFilter,
        initialRegionFilter: currentRegionFilter,
        initialMinSpaces: currentMinSpaces,
        initialMinDownloads: currentMinDownloads,
        metrics: METRICS,
        minSpacesOptions: MIN_SPACES_OPTIONS,
        minDownloadsOptions: MIN_DOWNLOAD_OPTIONS,
        onModeChange:onConfigModeChange,
        onPeriodChange:onConfigPeriodChange,
        onScaleChange:onConfigScaleChange,
        onNormModeChange:onConfigNormModeChange,
        onMetricChange:onConfigMetricChange,
        onSliderVisibilityChange:setSliderVisibility,
        onTopFilterChange:onConfigTopFilterChange,
        onTitleVisibilityChange:setTitleVisibility,
        onOrgFilterChange:onConfigOrgFilterChange,
        onRegionFilterChange:onConfigRegionFilterChange,
        onMinSpacesChange:onConfigMinSpacesChange,
        onMinDownloadsChange:onConfigMinDownloadsChange
      });
    }
    const panelEl=document.getElementById("configPanel");
    if(panelEl){ wireConfigSliderBridge(panelEl); }
  }catch(err){
    console.error("Failed to load config tab:",err);
  }
}

function load(){
  const dataPromise=INLINE_DATA?Promise.resolve(INLINE_DATA):fetch("./repos1.json").then(r=>r.json());
  const orgPromise=INLINE_ORGS?Promise.resolve(INLINE_ORGS):fetch("./orgs.json").then(r=>r.ok?r.json():[]).catch(()=>[]);
  Promise.all([dataPromise, orgPromise]).then(([json, orgList])=>{
    const sourceData=Array.isArray(json)?json.slice():[];
    const sourceOrgList=Array.isArray(orgList)?orgList.slice():[];
    orgMeta.clear();
    if(Array.isArray(sourceOrgList)){
      sourceOrgList.forEach(entry=>{
        if(entry&&entry.id){
          const regionText=typeof entry.region==="string"?entry.region.trim():null;
          preloadLogo(entry.logo);
          orgMeta.set(entry.id,{
            color:entry.color||null,
            logo:entry.logo||null,
            company:entry.company===true,
            region:regionText,
            regionKey:normalizeRegionKey(regionText)
          });
        }
      });
    }
    const grouped=d3.groups(sourceData,d=>d.id).map(([id,arr])=>{
      arr.sort((a,b)=>+a.week_count-+b.week_count);
      const enriched=arr.map(entry=>{
        const weekDate=parseDateYYYYMMDD(entry.week_date);
        const monthDate=parseDateYYYYMMDD(entry.month_date);
        return {...entry, __weekDate:weekDate, __monthDate:monthDate, __date:weekDate||null};
      });
      return {id, values:enriched};
    });
    rawById=grouped;
    const ids=rawById.map(s=>s.id);
    ids.forEach(id=>{
      const shouldBeActive=inlineActiveIdSet?inlineActiveIdSet.has(id):true;
      active.set(id,shouldBeActive);
    });
    inlineActiveIdSet=null;
    colorScale.domain(ids);
    const defaultMetric=METRICS.length?METRICS[0].key:null;
    let filterMetric=currentFilter.metric;
    if(!filterMetric|| (filterMetric!=="downloads_per_repo"&&!METRICS.some(m=>m.key===filterMetric))){
      filterMetric=defaultMetric;
    }
    currentFilter={ percent:clampFilterPercent(currentFilter.percent), metric:filterMetric };
    setRegionFilter(currentRegionFilter,{ force:true, skipConfig:true, skipRender:true });
    setOrgFilter(currentOrgFilter,{ force:true, skipConfig:true, skipRender:true });
    updateAxisLabel();
    if(window.ConfigTab&&typeof window.ConfigTab.setMetrics==="function"){ window.ConfigTab.setMetrics(METRICS,currentMetric); }
    if(window.ConfigTab&&typeof window.ConfigTab.setScale==="function"){ window.ConfigTab.setScale(currentScale); }
    if(window.ConfigTab&&typeof window.ConfigTab.setModeDisabled==="function"){ window.ConfigTab.setModeDisabled(currentScale==="normalized"); }
    if(window.ConfigTab&&typeof window.ConfigTab.setNormModeVisible==="function"){ window.ConfigTab.setNormModeVisible(currentScale==="normalized"); }
    if(window.ConfigTab&&typeof window.ConfigTab.setNormMode==="function"){ window.ConfigTab.setNormMode(currentNormMode); }
    if(window.ConfigTab&&typeof window.ConfigTab.setSliderVisible==="function"){ window.ConfigTab.setSliderVisible(sliderVisible); }
    if(window.ConfigTab&&typeof window.ConfigTab.setTitleVisible==="function"){ window.ConfigTab.setTitleVisible(titleVisible); }
    if(window.ConfigTab&&typeof window.ConfigTab.setTopFilter==="function"){ window.ConfigTab.setTopFilter(currentFilter); }
    if(window.ConfigTab&&typeof window.ConfigTab.setSliderVisible==="function"){ window.ConfigTab.setSliderVisible(sliderVisible); }
    if(window.ConfigTab&&typeof window.ConfigTab.setTitleVisible==="function"){ window.ConfigTab.setTitleVisible(titleVisible); }
    if(window.ConfigTab&&typeof window.ConfigTab.setOrgFilter==="function"){ window.ConfigTab.setOrgFilter(currentOrgFilter); }
    if(window.ConfigTab&&typeof window.ConfigTab.setRegionFilter==="function"){ window.ConfigTab.setRegionFilter(currentRegionFilter); }
    buildSeriesFromRaw();
    render();
  }).catch(()=>{
    orgMeta.clear();
    rawById=[];
    series=[];
    currentTimeline=[];
    legendFullIds=[];
    legendCurrentIds=[];
    syncRangeWithTimeline();
    render();
  });
}

function buildSeriesFromRaw(){
  const metricKey=getActiveMetricKey();
  const isPerPeriod=currentMode==="perWeek";
  const period=currentPeriod;
  const infoByOrder=new Map();
  rawById.forEach(({values})=>{
    values.forEach(entry=>{
      const info=getPeriodInfo(entry,period);
      if(!info){ return; }
      const existing=infoByOrder.get(info.order);
      if(existing){
        if(!existing.date&&info.date){ infoByOrder.set(info.order,{...existing,date:info.date}); }
      }else{
        infoByOrder.set(info.order,{...info});
      }
    });
  });
  const sortedInfos=Array.from(infoByOrder.values()).sort((a,b)=>a.order-b.order);
  if(!sortedInfos.length){
    series=[];
    currentTimeline=[];
    return;
  }
  const baseInfo=sortedInfos.find(info=>info.date)||sortedInfos[0];

  const minOrder=sortedInfos[0].order;
  const maxOrder=sortedInfos[sortedInfos.length-1].order;
  const timeline=[];
  for(let order=minOrder,index=1; order<=maxOrder; order++, index++){
    let info=infoByOrder.get(order);
    if(info){ info={...info}; } else { info=createInfoFromOrder(order,period,baseInfo); }
    if(period==="weekly"&&!info.date&&baseInfo&&baseInfo.date){
      const diff=order-baseInfo.order;
      info.date=addDays(baseInfo.date,diff*7);
    }
    if(!info.label){
      if(period==="monthly"){
        const {year,month}=orderToYearMonth(order);
        info.label=formatMonthLabel(new Date(Date.UTC(year,month,1)));
      }else if(period==="yearly"){
        info.label=`${order}`;
      }else{
        info.label=formatWeekLabel(info.date);
      }
    }
    if(period==="monthly"&&(!Number.isInteger(info.month)||!Number.isInteger(info.year))){
      const {year,month}=orderToYearMonth(order);
      info.month=month;
      info.year=year;
    }
    if(period==="weekly"&&info.date){
      info.year=info.date.getUTCFullYear();
      info.month=info.date.getUTCMonth();
    }
    info.index=index;
    timeline.push(info);
  }
  timeline.forEach((info,idx)=>{ info.relativeIndex=idx; info.absoluteIndex=info.index; info.coord=info.index; });
  currentTimeline=timeline;

  series=rawById.map(({id, values})=>{
    const aggregated=new Map();
    values.forEach(entry=>{
      const info=getPeriodInfo(entry,period);
      if(!info){ return; }
      const target=aggregated.get(info.order)||{sum:0,last:null};
      if(isPerPeriod){ target.sum+=+entry[metricKey]||0; } else { target.last=+entry[metricKey]||0; }
      aggregated.set(info.order,target);
    });
    const result=[];
    let running=0;
    currentTimeline.forEach(info=>{
      const dataPoint=aggregated.get(info.order);
      let rawValue=0;
      let endValue=running;
      if(isPerPeriod){
        rawValue=dataPoint?dataPoint.sum:0;
        endValue=rawValue;
      }else{
        if(currentMode==="cumulative"){
          rawValue=running;
          if(dataPoint&&typeof dataPoint.last==="number"){
            running=dataPoint.last;
          }
          endValue=running;
        }else{
          if(dataPoint&&typeof dataPoint.last==="number"){
            running=dataPoint.last;
          }
          rawValue=running;
          endValue=running;
        }
      }
      result.push({ w:info.coord, rawValue, value:rawValue, endValue, label:info.label, actualLabel:info.label, relativeLabel:null, order:info.order, date:info.date, relativeIndex:info.relativeIndex, absoluteIndex:info.absoluteIndex });
    });
    return {id, values:result};
  });
  syncRangeWithTimeline();
}

function measureLabelWidth(labels,fontSize){
  const g=svg.append("g").attr("opacity",0).attr("transform","translate(-9999,-9999)");
  const t=g.selectAll("text").data(labels).enter().append("text").style("font-size",fontSize+"px").text(d=>d);
  let w=0;
  t.each(function(){ w=Math.max(w,this.getComputedTextLength()); });
  g.remove();
  return w;
}

function getTimelineInfoByCoord(coord){
  if(!currentTimeline.length||!Number.isFinite(coord)){ return null; }
  const idx=Math.round(coord)-1;
  if(idx<0||idx>=currentTimeline.length){ return null; }
  return currentTimeline[idx];
}

function formatTimelineTick(value){
  if(!currentTimeline.length){ return ""; }
  const info=getTimelineInfoByCoord(value);
  if(!info){ return ""; }
  if(currentPeriod==="yearly"){ return `${info.year||info.order}`; }
  if(currentPeriod==="monthly"){
    if(Number.isInteger(info.month)){ return getMonthLabel(info.month); }
    const label=info.label||"";
    return stripTimePrefix(label);
  }
  if(currentPeriod==="weekly"){
    const prev=getTimelineInfoByCoord(value-1);
    const isMonthStart=!prev||prev.month!==info.month||prev.year!==info.year;
    if(isMonthStart&&Number.isInteger(info.month)){
      return getMonthLabel(info.month);
    }
    return "";
  }
  const label=info.label||"";
  return stripTimePrefix(label);
}

function getPointLabel(point){
  if(!point){ return ""; }
  const info=getTimelineInfoByCoord(point.w);
  if(!info){ return ""; }
  return info.label||`Period ${point.w}`;
}

function getHoveredPeriodCount(point){
  if(currentMode==="perWeek"){
    return Number.isFinite(point.value)?point.value:0;
  }
  const s=series.find(s=>s.id===point.id);
  if(!s||!Array.isArray(s.values)){ return 0; }
  const idx=Number.isInteger(point.relativeIndex)?point.relativeIndex:0;
  const prevEntry=idx>0?s.values[idx-1]:null;
  const prevEnd=prevEntry&&Number.isFinite(prevEntry.endValue)?prevEntry.endValue:(prevEntry&&Number.isFinite(prevEntry.rawValue)?prevEntry.rawValue:0);
  const currEnd=Number.isFinite(point.endValue)?point.endValue:(Number.isFinite(point.rawValue)?point.rawValue:0);
  const delta=currEnd-prevEnd;
  return Number.isFinite(delta)?delta:0;
};

function createTooltipHtml(point,labelText,metricDef){
  const metricName=metricDef?metricDef.label:"";
  const modeLabel=currentScale==="normalized"?"":getModeSuffix();
  const scaleLabel=currentScale==="normalized"?"":getScaleSuffix();
  const lines=[];
  lines.push(`<strong>${point.id}</strong>`);
  lines.push(labelText);
  if(currentScale==="normalized"){
    const indexValue=formatValue(point.value);
    lines.push(`Index: ${indexValue}`);
    const actualSuffix=[metricName].filter(Boolean).join(" ").trim();
    const actualValue=formatRawValue(point.rawValue??point.value);
    lines.push(`Actual: ${actualValue}${actualSuffix?` ${actualSuffix}`:""}`);
  }else if(currentMode==="cumulative"){
    const unitSuffix=metricName?` ${metricName}`:"";
    lines.push(`So far: ${formatValue(point.value)}${unitSuffix}`);
  }else{
    let descriptor=[metricName,modeLabel,scaleLabel].filter(Boolean).join(" ").trim();
    descriptor=descriptor?` ${descriptor}`:"";
    const valueText=`${formatValue(point.value)}${descriptor}`.trim();
    lines.push(valueText);
  }
  const periodLabel=currentPeriod==="weekly"?"This week":currentPeriod==="monthly"?"This month":currentPeriod==="yearly"?"This year":"This period";
  const perCount=getHoveredPeriodCount(point);
  lines.push(`${periodLabel}: ${formatRawValue(perCount)}${metricName?` ${metricName}`:""}`);
  return lines.join("<br>");
};

function findNormalizationBaseEntry(slice){
  if(!Array.isArray(slice)){ return { index:-1, value:null }; }
  for(let i=0;i<slice.length;i++){
    const entry=slice[i];
    if(!entry){ continue; }
    const raw=entry.rawValue;
    if(Number.isFinite(raw)&&Math.abs(raw)>0){
      return { index:i, value:raw };
    }
  }
  return { index:-1, value:null };
}

function normalizeAgainstStart(slice){
  if(!Array.isArray(slice)||!slice.length){ return []; }
  const { index:baseIndex, value:divisor }=findNormalizationBaseEntry(slice);
  if(Number.isFinite(divisor)&&Math.abs(divisor)>0){
    return slice.map((entry,idx)=>{
      const raw=entry&&Number.isFinite(entry.rawValue)?entry.rawValue:null;
      let value=(Number.isFinite(raw)&&divisor)?(raw/divisor):0;
      if(idx===baseIndex){ value=1; }
      return { ...entry, value };
    });
  }
  return slice.map(entry=>({ ...entry, value:1 }));
}

function normalizeAgainstPrevious(slice){
  if(!Array.isArray(slice)||!slice.length){ return []; }
  const result=[];
  slice.forEach((entry,idx)=>{
    let value=1;
    if(idx>0){
      const prevRaw=slice[idx-1]?.rawValue;
      if(Number.isFinite(prevRaw)&&Math.abs(prevRaw)>0){
        const raw=entry?.rawValue;
        value=Number.isFinite(raw)?(raw/prevRaw):0;
      }else{
        const fallback=result[idx-1]?.value;
        value=Number.isFinite(fallback)?fallback:1;
      }
    }
    result.push({ ...entry, value });
  });
  return result;
}

function decimateTicksHalf(ticks){
  if(!Array.isArray(ticks)||ticks.length<=2){ return ticks; }
  const res=[];
  for(let i=0;i<ticks.length;i++){
    if(i===0||i===ticks.length-1||i%2===0){ res.push(ticks[i]); }
  }
  return Array.from(new Set(res));
}

function render(){
  const viz=document.getElementById("viz");
  const rect=viz.getBoundingClientRect();
  const fullW=rect.width;
  const fullH=rect.height;
  const axisContainer=document.querySelector("#container1 .y-axis-container");
  const axisContainerWidth=axisContainer?axisContainer.getBoundingClientRect().width:24;
  svg.attr("width",fullW).attr("height",fullH);
  const tickFont=Math.max(9,Math.min(13,fullW/110));
  const finalLabelFontSize=6;
  const yearAxisLabelPadding=tickFont+16;
  const yearLabelTextOffset=yearAxisLabelPadding+tickFont+8;
  const yearDecorationAllowance=yearLabelTextOffset+tickFont+18;
  if(!currentTimeline.length){
    svg.selectAll("*").remove();
    updateTitle([]);
    suppressAnimationNextRender=false;
    return;
  }
  const {startIndex,endIndex}=getClampedRangeIndices();
  const timelineSlice=currentTimeline.filter(info=>info.relativeIndex>=startIndex&&info.relativeIndex<=endIndex);
  if(!timelineSlice.length){
    svg.selectAll("*").remove();
    updateTitle([]);
    suppressAnimationNextRender=false;
    return;
  }
  const shouldShowYearDividers=(currentPeriod==="weekly"||currentPeriod==="monthly")&&timelineSlice.some(info=>Number.isInteger(info.year));
  updateTitle(timelineSlice);
  const rangeMinCoord=timelineSlice[0].coord;
  const rangeMaxCoord=timelineSlice[timelineSlice.length-1].coord;
  const singlePoint=rangeMinCoord===rangeMaxCoord;
  const domainMin=singlePoint?rangeMinCoord-0.5:rangeMinCoord;
  const domainMax=singlePoint?rangeMaxCoord+0.5:rangeMaxCoord;

  const orgFilteredSeries=filterSeriesByOrg(series);
  const filteredSeries=transformSeriesForRange(orgFilteredSeries,startIndex,endIndex);
  const filterMetricKey=currentFilter.metric||currentMetric;
  const filterPercent=Number.isFinite(currentFilter.percent)?currentFilter.percent:100;
  const limitCount=getFilterLimitCount(filterPercent,legendFullIds.length);
  let filterScores;
  if(filterMetricKey==="downloads_per_repo"){
    filterScores=computeDownloadsPerRepoScores(startIndex,endIndex);
  }else if(filterMetricKey===currentMetric){
    filterScores=computeScoresFromSeries(filteredSeries);
  }else{
    const baseSeries=filterSeriesByOrg(buildSeriesForMetric(filterMetricKey));
    const transformed=transformSeriesForRange(baseSeries,startIndex,endIndex);
    filterScores=computeScoresFromSeries(transformed);
  }

  if(limitCount===null){
    legendFullIds.forEach(id=>active.set(id,true));
    if(!arraysEqual(legendCurrentIds,legendFullIds)){ buildLegend(legendFullIds); }
  }else if(limitCount<=0){
    legendFullIds.forEach(id=>active.set(id,false));
    if(!arraysEqual(legendCurrentIds,[])){ buildLegend([]); }
  }else{
    const topIds=computeTopIdsFromScores(limitCount,filterScores);
    const uniqueTopIds=Array.from(new Set(topIds));
    legendFullIds.forEach(id=>{ active.set(id,uniqueTopIds.includes(id)); });
    if(!arraysEqual(legendCurrentIds,uniqueTopIds)){ buildLegend(uniqueTopIds); }
  }
  refreshLegendState();

  const activeSeries=filteredSeries.filter(s=>active.get(s.id));
  const visibleSeries=activeSeries.filter(s=>s.values.length);
  const visiblePointCount=visibleSeries.reduce((sum,s)=>sum+s.values.length,0);
  const densePointMode=visiblePointCount>100;
  const seriesForScale=visibleSeries.length?visibleSeries:activeSeries.length?activeSeries:filteredSeries;
  const useLogScale=currentScale==="log";
  let yMax=d3.max(seriesForScale,s=>d3.max(s.values,v=>v.value));
  let yMin=d3.min(seriesForScale,s=>d3.min(s.values,v=>v.value));
  if(!Number.isFinite(yMax)){ yMax=1; }
  if(!Number.isFinite(yMin)){ yMin=useLogScale?1:0; }
  if(yMax<yMin){ const swap=yMax; yMax=yMin; yMin=swap; }

  let minPositive=Infinity;
  let maxPositive=-Infinity;
  if(useLogScale){
    seriesForScale.forEach(s=>{
      s.values.forEach(v=>{
        if(Number.isFinite(v.value)&&v.value>0){
          if(v.value<minPositive){ minPositive=v.value; }
          if(v.value>maxPositive){ maxPositive=v.value; }
        }
      });
    });
  }

  const tickTarget=Math.max(3,Math.round(fullH*0.6/60));
  let yTickValues=[];
  let safeMinPositive=null;

  if(useLogScale){
    if(!Number.isFinite(minPositive)||minPositive<=0){ minPositive=1; }
    if(!Number.isFinite(maxPositive)||maxPositive<=0){ maxPositive=minPositive; }
    yMin=minPositive;
    if(Number.isFinite(maxPositive)&&maxPositive>yMin){
      yMax=maxPositive;
    }else{
      yMax=yMin*10;
    }
    if(yMax<=yMin){ yMax=yMin*10; }
    const tmpY=d3.scaleLog().base(10).domain([yMin,yMax]);
    yTickValues=tmpY.ticks(tickTarget);
    yTickValues=[yMin,...yTickValues,yMax];
    yTickValues=yTickValues.filter(v=>Number.isFinite(v)&&v>=yMin&&v<=yMax);
    yTickValues=Array.from(new Set(yTickValues)).sort((a,b)=>a-b);
    safeMinPositive=yMin;
  }else{
    if(yMax===yMin){
      const pad=Math.abs(yMax)||1;
      yMax=yMax+pad*0.05;
    }
    const tmpY=d3.scaleLinear().domain([yMin,yMax]).range([100,0]);
    yTickValues=tmpY.ticks(tickTarget);
    if(!yTickValues.includes(yMin)){ yTickValues=[yMin,...yTickValues]; }
    if(!yTickValues.includes(yMax)){ yTickValues=[...yTickValues,yMax]; }
    yTickValues=Array.from(new Set(yTickValues)).sort((a,b)=>a-b);
  }
  const yTicks=yTickValues.map(formatValue);
  const yLabelW=measureLabelWidth(yTicks,tickFont);

  let bottomMargin=Math.max(36,fullH*0.16,yearDecorationAllowance);
  const margin={ top:Math.max(10,fullH*0.04), right:Math.max(16,fullW*0.05), bottom:bottomMargin, left:Math.max(8,axisContainerWidth+yLabelW+6) };

  const width=Math.max(0,fullW-margin.left-margin.right);
  const height=Math.max(0,fullH-margin.top-margin.bottom);
  const gRoot=svg.selectAll("g.root").data([null]).join("g").attr("class","root").attr("transform",`translate(${margin.left},${margin.top})`);
  if(width<=0||height<=0){
    suppressAnimationNextRender=false;
    return;
  }

  const x=d3.scaleLinear().domain([domainMin,domainMax]).range([0,width]);
  const y=useLogScale?d3.scaleLog().base(10).domain([yMin,yMax]).range([height,0]).clamp(true):d3.scaleLinear().domain([yMin,yMax]).range([height,0]);
  const valueForPlot=d=>{
    const val=d.value;
    if(!Number.isFinite(val)){
      return useLogScale?(safeMinPositive||1):0;
    }
    if(useLogScale){
      return Math.max(val,safeMinPositive||1);
    }
    return val;
  };
  const xTickCount=Math.max(3,Math.round(width/90));
  const allowedCoords=new Set(timelineSlice.map(info=>info.coord));
  let fullXTicks=[];
  let axisXTicks=[];
  if(currentPeriod==="weekly"){
    const allCoords=timelineSlice.map(info=>info.coord);
    const monthStartCoords=[];
    timelineSlice.forEach((info,idx)=>{
      const isFirst=idx===0;
      const prev=isFirst?null:timelineSlice[idx-1];
      const monthChanged=isFirst||!prev||prev.month!==info.month||prev.year!==info.year;
      if(monthChanged){ monthStartCoords.push(info.coord); }
    });
    const baseTicks=new Set([rangeMinCoord,rangeMaxCoord]);
    monthStartCoords.forEach(coord=>{ if(allowedCoords.has(coord)){ baseTicks.add(coord); } });
    let monthTicks=Array.from(baseTicks).filter(coord=>allowedCoords.has(coord)).sort((a,b)=>a-b);
    const monthLabels=monthTicks.map(coord=>{
      const info=getTimelineInfoByCoord(coord);
      if(!info||!Number.isInteger(info.month)){ return ""; }
      return getMonthLabel(info.month);
    });
    const approxMonthLabelWidth=monthLabels.length?measureLabelWidth(monthLabels,tickFont):0;
    const minTickSpacing=Math.max(approxMonthLabelWidth?approxMonthLabelWidth+12:60,40);
    const filteredMonthTicks=[];
    if(monthTicks.length){
      filteredMonthTicks.push(monthTicks[0]);
      for(let i=1;i<monthTicks.length-1;i++){
        const coord=monthTicks[i];
        const last=filteredMonthTicks[filteredMonthTicks.length-1];
        if(x(coord)-x(last)>=minTickSpacing){
          filteredMonthTicks.push(coord);
        }
      }
      const lastCoord=monthTicks[monthTicks.length-1];
      const lastKept=filteredMonthTicks[filteredMonthTicks.length-1];
      if(lastCoord!==lastKept){
        if(x(lastCoord)-x(lastKept)<minTickSpacing&&filteredMonthTicks.length>1){
          filteredMonthTicks[filteredMonthTicks.length-1]=lastCoord;
        }else{
          filteredMonthTicks.push(lastCoord);
        }
      }
    }
    const weekCoords=allCoords.filter(coord=>!filteredMonthTicks.includes(coord));
    const targetTickCount=Math.min(Math.floor(width/Math.max(minTickSpacing,1)), filteredMonthTicks.length+weekCoords.length);
    const tickArray=filteredMonthTicks.slice();
    if(targetTickCount>tickArray.length){
      const tryAddTick=coord=>{
        const pos=x(coord);
        for(let i=0;i<tickArray.length;i++){
          const existingPos=x(tickArray[i]);
          if(Math.abs(existingPos-pos)<minTickSpacing){ return false; }
        }
        tickArray.push(coord);
        tickArray.sort((a,b)=>a-b);
        return true;
      };
      for(let i=0;i<weekCoords.length&&tickArray.length<targetTickCount;i++){
        const coord=weekCoords[i];
        if(!allowedCoords.has(coord)){ continue; }
        tryAddTick(coord);
      }
    }
    axisXTicks=tickArray;
    fullXTicks=tickArray.slice();
  }else{
    let rawTicks=d3.ticks(rangeMinCoord,rangeMaxCoord,xTickCount);
    rawTicks=rawTicks.map(val=>Math.round(val));
    rawTicks=Array.from(new Set(rawTicks)).filter(t=>allowedCoords.has(t));
    if(singlePoint){
      rawTicks=[rangeMinCoord];
    }else{
      if(!rawTicks.includes(rangeMinCoord)){ rawTicks.unshift(rangeMinCoord); }
      if(!rawTicks.includes(rangeMaxCoord)){ rawTicks.push(rangeMaxCoord); }
    }
    rawTicks.sort((a,b)=>a-b);
    fullXTicks=rawTicks;
    axisXTicks=decimateTicksHalf(rawTicks);
  }

  const gridX=gRoot.selectAll("g.grid-x").data([null]).join("g").attr("class","grid grid-x").attr("transform",`translate(0,${height})`);
  gridX.call(d3.axisBottom(x).tickValues(fullXTicks).tickSize(-height).tickFormat(""));
  const gridY=gRoot.selectAll("g.grid-y").data([null]).join("g").attr("class","grid grid-y");
  gridY.call(d3.axisLeft(y).tickValues(yTickValues).tickSize(-width).tickFormat(""));
  gridX.select(".domain").remove();
  gridY.select(".domain").remove();

  const xAxis=gRoot.selectAll("g.x").data([null]).join("g").attr("class","axis x").attr("transform",`translate(0,${height})`);
  const yAxis=gRoot.selectAll("g.y").data([null]).join("g").attr("class","axis y");
  xAxis.call(d3.axisBottom(x).tickValues(axisXTicks).tickFormat(formatTimelineTick));
  yAxis.call(d3.axisLeft(y).tickValues(yTickValues).tickFormat(formatValue).tickPadding(2));
  svg.selectAll(".axis text").style("font-size",tickFont+"px");

  if(shouldShowYearDividers){
    const yearRanges=[];
    let currentYear=null;
    let startCoord=null;
    let lastCoord=null;
    timelineSlice.forEach(info=>{
        const infoYear=Number.isInteger(info.year)?info.year:(info.date instanceof Date?info.date.getUTCFullYear():null);
        if(infoYear===null){ return; }
        if(currentYear===null){
        currentYear=infoYear;
        startCoord=info.coord;
        lastCoord=info.coord;
        return;
        }
        if(infoYear!==currentYear){
        yearRanges.push({ year:currentYear, startCoord, endCoord:lastCoord??startCoord });
        currentYear=infoYear;
        startCoord=info.coord;
        }
        lastCoord=info.coord;
    });
    if(currentYear!==null){
        yearRanges.push({ year:currentYear, startCoord:startCoord??timelineSlice[0].coord, endCoord:lastCoord??timelineSlice[timelineSlice.length-1].coord });
    }
    const rangesAvailable=yearRanges.filter(range=>Number.isFinite(range.startCoord)&&Number.isFinite(range.endCoord));
    const baseCoord=timelineSlice[0]?.coord;
    let halfStep=null;
    if(timelineSlice.length>1){
        const next=timelineSlice.find(info=>info.coord!==baseCoord);
        if(next){ halfStep=Math.abs(x(next.coord)-x(baseCoord))/2; }
    }
    if(!Number.isFinite(halfStep)||halfStep<=0){
        halfStep=timelineSlice.length>1?(width/(timelineSlice.length-1))/2:width/2;
    }
    const rangesForRender=rangesAvailable.map(range=>{
        const startX=Math.max(0,x(range.startCoord)-halfStep);
        const endX=Math.min(width,x(range.endCoord)+halfStep);
        return { ...range, startX, endX, labelX:(startX+endX)/2 };
    }).filter(range=>Number.isFinite(range.startX)&&Number.isFinite(range.endX)&&range.endX>range.startX+0.5);
    const yearLabelFontSize=Math.max(9,Math.min(13,tickFont+1));
    const group=gRoot.selectAll("g.year-dividers")
    .data([null])
    .join("g")
    .attr("class","year-dividers")
    .attr("transform",`translate(0,${height})`);

    const items=group.selectAll("g.year-divider").data(rangesForRender,d=>`${d.year}-${d.startCoord}-${d.endCoord}`);
    items.exit().remove();
    const enter=items.enter().append("g").attr("class","year-divider");
    enter.append("line").attr("class","year-line");
    enter.append("line").attr("class","year-cap-start");
    enter.append("line").attr("class","year-cap-end");
    enter.append("text").attr("class","year-label").attr("text-anchor","middle").attr("dominant-baseline","alphabetic");
    const merged=enter.merge(items);
    const lineY=yearAxisLabelPadding;
    const labelY=yearLabelTextOffset;
    const axisLineColor=getCssVar("--viz-axis-line","#cfd2d7");
    const mutedLabelColor=getCssVar("--viz-muted-text","#6e7485");
    merged.select(".year-line")
        .attr("x1",d=>d.startX).attr("x2",d=>d.endX)
        .attr("y1",lineY).attr("y2",lineY)
        .attr("stroke-width",1).attr("stroke",axisLineColor);
    merged.select(".year-cap-start")
        .attr("x1",d=>d.startX).attr("x2",d=>d.startX)
        .attr("y1",lineY-4).attr("y2",lineY+4)
        .attr("stroke-width",1).attr("stroke",axisLineColor);
    merged.select(".year-cap-end")
        .attr("x1",d=>d.endX).attr("x2",d=>d.endX)
        .attr("y1",lineY-4).attr("y2",lineY+4)
        .attr("stroke-width",1).attr("stroke",axisLineColor);
    merged.select(".year-label")
        .attr("x",d=>d.labelX).attr("y",labelY)
        .text(d=>d.year)
        .style("font-size",yearLabelFontSize+"px")
        .style("fill",mutedLabelColor);
    }else{
    gRoot.selectAll("g.year-dividers").remove();
    }

  const minWindowSize=480;
  const maxWindowSize=1400;
  const windowMeasure=Math.max(width,height);
  const windowSpan=Math.max(1,maxWindowSize-minWindowSize);
  const windowRatio=Math.max(0,Math.min(1,(windowMeasure-minWindowSize)/windowSpan));
  const smallRadiusBase=2.4;
  let smallRadius=smallRadiusBase*(0.8+windowRatio*(2-0.8));
  if(densePointMode){ smallRadius*=0.6; }
  const finalRadiusBase=6;
  const finalRadius=finalRadiusBase*(1+windowRatio);
  const finalLogoRadius=finalRadius*(1+0.2*windowRatio);
  const finalHoverRadius=finalRadius*1.18;
  const finalLogoHoverRadius=finalLogoRadius*1.12;
  const hoverRadius=smallRadius*1.6;
  const lineW=0.9+windowRatio*1.6;
  const lineGen=d3.line().x(d=>x(d.w)).y(d=>y(valueForPlot(d)));
  const shouldAnimate=!suppressAnimationNextRender;
  const transitionDuration=shouldAnimate?360:0;
  const exitDuration=shouldAnimate?Math.round(transitionDuration*0.6):0;
  const easeFn=d3.easeCubicOut;

  const seriesSel=gRoot.selectAll("path.series").data(visibleSeries,d=>d.id);
  const seriesExit=seriesSel.exit().interrupt();
  if(shouldAnimate){
    seriesExit.transition().duration(exitDuration).attr("opacity",0).remove();
  }else{
    seriesExit.remove();
  }
  const seriesEnter=seriesSel.enter().append("path").attr("class","series").attr("fill","none").attr("stroke",d=>getSeriesColor(d.id)).attr("stroke-width",lineW).attr("d",d=>lineGen(d.values)).attr("opacity",shouldAnimate?0:1);
  const seriesMerged=seriesEnter.merge(seriesSel);
  if(shouldAnimate){
    seriesMerged.interrupt().transition().duration(transitionDuration).ease(easeFn).attr("stroke-width",lineW).attr("stroke",d=>getSeriesColor(d.id)).attr("d",d=>lineGen(d.values)).attr("opacity",1);
  }else{
    seriesMerged.interrupt().attr("stroke-width",lineW).attr("stroke",d=>getSeriesColor(d.id)).attr("d",d=>lineGen(d.values)).attr("opacity",1);
  }

  const groupsSel=gRoot.selectAll("g.dots").data(visibleSeries,d=>d.id);
  const groupsExit=groupsSel.exit().interrupt();
  if(shouldAnimate){
    groupsExit.transition().duration(exitDuration).style("opacity",0).remove();
  }else{
    groupsExit.remove();
  }
  const groupsEnter=groupsSel.enter().append("g").attr("class","dots").style("opacity",shouldAnimate?0:1);
  const groupsMerged=groupsEnter.merge(groupsSel);
  if(shouldAnimate){
    groupsMerged.interrupt().transition().duration(transitionDuration).ease(easeFn).style("opacity",1);
  }else{
    groupsMerged.interrupt().style("opacity",1);
  }

  groupsMerged.each(function(s){
    const baseR=smallRadius;
    const seriesColor=getSeriesColor(s.id);
    const orgInfo=getOrgInfo(s.id);
    const patternId=orgInfo&&orgInfo.logo?ensureLogoPattern(s.id,orgInfo.logo):null;
    const defaultDotFill=getCssVar("--viz-body-bg","#ffffff");
    const finalFillValue=patternId?`url(#${patternId})`:defaultDotFill;
    const getDotRadius=datum=>datum.isFinal?(datum.logoUrl?finalLogoRadius:finalRadius):baseR;
    const getHoverRadius=datum=>datum.isFinal?(datum.logoUrl?finalLogoHoverRadius:finalHoverRadius):hoverRadius;
    const data=s.values.map((v,i)=>({
      id:s.id,
      w:v.w,
      value:v.value,
      rawValue:v.rawValue,
      endValue:v.endValue,
      displayEndValue:v.displayEndValue,
      plotValue:valueForPlot(v),
      label:v.label,
      actualLabel:v.actualLabel,
      relativeLabel:v.relativeLabel,
      relativeIndex:v.relativeIndex,
      order:v.order,
      date:v.date,
      isFinal:i===s.values.length-1,
      logoUrl:orgInfo&&orgInfo.logo?orgInfo.logo:null
    }));
    const logoData=data.filter(d=>d.isFinal&&d.logoUrl);
    const bgSel=d3.select(this).selectAll("circle.dot-logo-bg").data(logoData,d=>`${d.id}-${d.w}`);
    const bgEnter=bgSel.enter().append("circle").attr("class","dot-logo-bg").attr("pointer-events","none").lower();
    bgEnter.merge(bgSel)
      .attr("cx",d=>x(d.w))
      .attr("cy",d=>y(d.plotValue))
      .attr("r",d=>getDotRadius(d))
      .attr("fill",defaultDotFill)
      .attr("data-key",d=>`${d.id}-${d.w}`);
    bgSel.exit().remove();
    const sel=d3.select(this).selectAll("circle.dot").data(data,d=>`${d.id}-${d.w}`);
    const exitSel=sel.exit().interrupt();
    if(shouldAnimate){
      exitSel.transition().duration(exitDuration).attr("opacity",0).remove();
    }else{
      exitSel.remove();
    }
    const enterSel=sel.enter().append("circle").attr("class","dot").attr("opacity",shouldAnimate?0:1).attr("stroke-width",1).style("pointer-events","all").attr("cx",d=>x(d.w)).attr("cy",d=>y(d.plotValue)).attr("r",d=>getDotRadius(d)).attr("fill",d=>d.isFinal?finalFillValue:seriesColor).attr("stroke",seriesColor).attr("data-logo-url",d=>(d.isFinal&&d.logoUrl)?d.logoUrl:null);
    const mergedSel=enterSel.merge(sel);
    if(shouldAnimate){
      mergedSel.interrupt().transition().duration(transitionDuration).ease(easeFn).attr("opacity",1).attr("cx",d=>x(d.w)).attr("cy",d=>y(d.plotValue)).attr("r",d=>getDotRadius(d)).attr("fill",d=>d.isFinal?finalFillValue:seriesColor).attr("stroke",seriesColor).attr("data-logo-url",d=>(d.isFinal&&d.logoUrl)?d.logoUrl:null);
    }else{
      mergedSel.interrupt().attr("opacity",1).attr("cx",d=>x(d.w)).attr("cy",d=>y(d.plotValue)).attr("r",d=>getDotRadius(d)).attr("fill",d=>d.isFinal?finalFillValue:seriesColor).attr("stroke",seriesColor).attr("data-logo-url",d=>(d.isFinal&&d.logoUrl)?d.logoUrl:null);
    }
  mergedSel
    .on("pointerenter",function(event,d){
      const seriesPath=gRoot.selectAll("path.series").filter(series=>series.id===d.id);
      seriesPath.raise();
      const parentGroup=d3.select(this.parentNode);
      parentGroup.raise();
      const finalLabel=gRoot.selectAll("text.final-label").filter(label=>label.id===d.id);
      finalLabel.raise();
      const bgCircle=parentGroup.select(`circle.dot-logo-bg[data-key="${d.id}-${d.w}"]`);
      const targetRadius=getHoverRadius(d);
      const circleSel=d3.select(this).raise();
      circleSel.transition().duration(160).attr("r",targetRadius);
      if(!bgCircle.empty()){
        bgCircle.transition().duration(160).attr("r",targetRadius);
      }
      const metricDef=getMetricDefinition();
      const labelText=getPointLabel(d);
      const tooltipHtml=createTooltipHtml(d,labelText,metricDef);
      const vizBox=document.getElementById("viz").getBoundingClientRect();
      const tipW=(tooltip.node()&&tooltip.node().offsetWidth)||0;
      const mouseX=event.clientX-vizBox.left;
      const mouseY=event.clientY-vizBox.top;
      const tx=mouseX-tipW-10;
      const ty=mouseY-10;
      tooltip.style("opacity",1).style("left",tx+"px").style("top",ty+"px").html(tooltipHtml);
    })
    .on("pointermove",function(event){
      const vizBox=document.getElementById("viz").getBoundingClientRect();
      const tipW=(tooltip.node()&&tooltip.node().offsetWidth)||0;
      const mouseX=event.clientX-vizBox.left;
      const mouseY=event.clientY-vizBox.top;
      const tx=mouseX-tipW-10;
      const ty=mouseY-10;
      tooltip.style("left",tx+"px").style("top",ty+"px");
    })
    .on("pointerleave",function(event,d){
      const baseRadius=getDotRadius(d);
      d3.select(this).transition().duration(160).attr("r",baseRadius);
      const bgCircle=d3.select(this.parentNode).select(`circle.dot-logo-bg[data-key="${d.id}-${d.w}"]`);
      if(!bgCircle.empty()){
        bgCircle.transition().duration(160).attr("r",baseRadius);
      }
      tooltip.style("opacity",0);
    });
  });

  const minLabelDisplayWidth=380;
  const minLabelDisplayHeight=240;
  const shouldShowLabels=visibleSeries.length>0&&width>minLabelDisplayWidth&&height>minLabelDisplayHeight&&windowMeasure>minWindowSize+1;
  const labelPadding=6;
  const labelOffset=finalRadius+labelPadding;
  const estimateWidth=text=>Math.max(0,(text?text.length:0)*finalLabelFontSize*0.6);
  const minVerticalGap=finalLabelFontSize+4;
  let finalLabelData=[];
  if(shouldShowLabels){
    const baseData=visibleSeries.map(s=>{
      if(!s.values.length){ return null; }
      const last=s.values[s.values.length-1];
      const text=s.id;
      const baseX=x(last.w);
      return {
        id:s.id,
        x:baseX,
        y:y(valueForPlot(last)),
        text,
        displayX:baseX+labelOffset,
        width:estimateWidth(text)
      };
    }).filter(Boolean);
    const filtered=[];
    baseData.sort((a,b)=>a.y===b.y?b.displayX-a.displayX:a.y-b.y).forEach(candidate=>{
      const overlaps=filtered.some(placed=>{
        const verticalOverlap=Math.abs(candidate.y-placed.y)<minVerticalGap;
        const horizontalOverlap=Math.abs(candidate.displayX-placed.displayX)<Math.max(candidate.width,placed.width);
        return verticalOverlap&&horizontalOverlap;
      });
      if(!overlaps){
        filtered.push(candidate);
      }
    });
    finalLabelData=filtered;
  }
  const labelsSel=gRoot.selectAll("text.final-label").data(finalLabelData,d=>d.id);
  const labelsExit=labelsSel.exit().interrupt();
  if(shouldAnimate){
    labelsExit.transition().duration(exitDuration).attr("opacity",0).remove();
  }else{
    labelsExit.remove();
  }
  const labelsEnter=labelsSel.enter().append("text").attr("class","final-label").attr("text-anchor","start").attr("dominant-baseline","middle").style("pointer-events","none").style("font-size",finalLabelFontSize+"px").attr("opacity",shouldAnimate?0:1).attr("x",d=>d.displayX).attr("y",d=>d.y);
  const labelsMerged=labelsEnter.merge(labelsSel);
  labelsMerged.interrupt();
  labelsMerged.text(d=>d.text).style("font-size",finalLabelFontSize+"px").style("fill",d=>getSeriesColor(d.id));
  if(shouldAnimate){
    labelsMerged.transition().duration(transitionDuration).ease(easeFn).attr("x",d=>d.displayX).attr("y",d=>d.y).attr("opacity",1);
  }else{
    labelsMerged.attr("x",d=>d.displayX).attr("y",d=>d.y).attr("opacity",1);
  }

  svg.selectAll("rect.pointer-capture").remove();
  suppressAnimationNextRender=false;
}

function formatTimestamp(date){
  const pad=value=>String(value).padStart(2,"0");
  const year=date.getFullYear();
  const month=pad(date.getMonth()+1);
  const day=pad(date.getDate());
  const hours=pad(date.getHours());
  const mins=pad(date.getMinutes());
  return `${year}${month}${day}-${hours}${mins}`;
}

function buildScreenshotFilename(){
  const metricDef=getMetricDefinition();
  const label=metricDef?metricDef.label:currentMetric;
  const slug=sanitizeForId(label||"view");
  const timestamp=formatTimestamp(new Date());
  return `viz-screenshot-${slug||"view"}-${timestamp}.png`;
}

function triggerDownloadUrl(url,filename,shouldRevoke){
  const link=document.createElement("a");
  link.href=url;
  link.download=filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  if(shouldRevoke){
    window.setTimeout(()=>{ URL.revokeObjectURL(url); },0);
  }
}

function ensureHtml2Canvas(){
  if(window.html2canvas){ return Promise.resolve(window.html2canvas); }
  if(html2canvasLoadingPromise){ return html2canvasLoadingPromise; }
  html2canvasLoadingPromise=new Promise((resolve,reject)=>{
    let script=document.getElementById("html2canvas-loader");
    if(!script){
      script=document.createElement("script");
      script.id="html2canvas-loader";
      script.src=HTML2CANVAS_SRC;
      script.defer=true;
      script.crossOrigin="anonymous";
      document.head.appendChild(script);
    }
    const handleLoad=()=>{
      script.removeEventListener("load",handleLoad);
      script.removeEventListener("error",handleError);
      if(window.html2canvas){
        resolve(window.html2canvas);
      }else{
        html2canvasLoadingPromise=null;
        reject(new Error("html2canvas loaded but is unavailable"));
      }
    };
    const handleError=()=>{
      script.removeEventListener("load",handleLoad);
      script.removeEventListener("error",handleError);
      html2canvasLoadingPromise=null;
      reject(new Error("Failed to load html2canvas"));
    };
    script.addEventListener("load",handleLoad,{ once:true });
    script.addEventListener("error",handleError,{ once:true });
  });
  return html2canvasLoadingPromise;
}

async function convertCanvasToBlob(canvas){
  if(!canvas){ throw new Error("Canvas not available"); }
  if(canvas.toBlob){
    return new Promise((resolve,reject)=>{
      canvas.toBlob(blob=>{
        if(blob){ resolve(blob); }else{ reject(new Error("Canvas blob conversion failed")); }
      },"image/png");
    });
  }
  const dataUrl=canvas.toDataURL("image/png");
  if(!dataUrl){ throw new Error("Unable to serialize canvas"); }
  const byteString=atob(dataUrl.split(",")[1]);
  const len=byteString.length;
  const array=new Uint8Array(len);
  for(let i=0;i<len;i++){ array[i]=byteString.charCodeAt(i); }
  return new Blob([array],{ type:"image/png" });
}

function drawFinalNodeLogosOnCanvas(canvas,target){
  if(!canvas||!target){ return; }
  const ctx=canvas.getContext("2d");
  if(!ctx){ return; }
  const targetRect=target.getBoundingClientRect();
  if(!targetRect||targetRect.width===0||targetRect.height===0){ return; }
  const scaleX=canvas.width/targetRect.width;
  const scaleY=canvas.height/targetRect.height;
  const circles=Array.from(document.querySelectorAll("#chart circle.dot[data-logo-url]"));
  circles.forEach(circle=>{
    const logoUrl=circle.getAttribute("data-logo-url");
    if(!logoUrl){ return; }
    const image=getPreloadedLogo(logoUrl);
    if(!image){ return; }
    const circleRect=circle.getBoundingClientRect();
    const radius=Math.max(circleRect.width,circleRect.height)/2;
    if(radius<=0){ return; }
    const centerX=(circleRect.left-targetRect.left)+radius;
    const centerY=(circleRect.top-targetRect.top)+radius;
    const drawRadius=Math.max(radius*scaleX,radius*scaleY);
    const drawX=centerX*scaleX;
    const drawY=centerY*scaleY;
    ctx.save();
    ctx.beginPath();
    ctx.arc(drawX,drawY,drawRadius,0,Math.PI*2);
    ctx.closePath();
    ctx.clip();
    ctx.drawImage(image,drawX-drawRadius,drawY-drawRadius,drawRadius*2,drawRadius*2);
    ctx.restore();
  });
}

async function handleDownloadClick(){
  if(!downloadButton||downloadButton.disabled){ return; }
  downloadButton.disabled=true;
  downloadButton.setAttribute("aria-busy","true");
  try{
    const html2canvasLib=await ensureHtml2Canvas();
    if(!html2canvasLib){ throw new Error("html2canvas is not available"); }
    const target=document.querySelector(SCREENSHOT_TARGET_SELECTOR);
    if(!target){ throw new Error("Screenshot target not found"); }
    const preloadPromises=Array.from(LOGO_PRELOADS.values()).map(entry=>entry.promise);
    if(preloadPromises.length){ await Promise.allSettled(preloadPromises); }
    const background=resolveBackgroundColor(target)||getCssVar("--viz-body-bg","#ffffff");
    const scale=Math.min(3, window.devicePixelRatio||2);
    const canvas=await html2canvasLib(target,{
      backgroundColor: background,
      useCORS: true,
      scale,
      logging: false,
      imageTimeout: 15000,
      ignoreElements: element=>{
        if(!element){ return false; }
        if(element.id==="downloadButton"){ return true; }
        if(element.classList&&element.classList.contains("viz-download-button")){ return true; }
        if(element.id==="sliderPanel"){ return true; }
        if(element.closest&&element.closest("#sliderPanel")){ return true; }
        return element.classList&&element.classList.contains("config-tab");
      }
    });
    drawFinalNodeLogosOnCanvas(canvas,target);
    const blob=await convertCanvasToBlob(canvas);
    const url=URL.createObjectURL(blob);
    triggerDownloadUrl(url,buildScreenshotFilename(),true);
  }catch(err){
    console.error("Failed to save visualization screenshot:",err);
  }finally{
    downloadButton.disabled=false;
    downloadButton.removeAttribute("aria-busy");
  }
}

async function fetchDataSource(minSpaces,minDownloads){
  if(INLINE_DATA){
    return Array.isArray(INLINE_DATA)?INLINE_DATA:[];
  }
  const key=buildDataKey(minSpaces,minDownloads);
  if(dataCache.has(key)){
    return dataCache.get(key);
  }
  const url=buildDataUrl(minSpaces,minDownloads);
  const response=await fetch(url);
  if(!response.ok){
    throw new Error(`HTTP ${response.status} while fetching ${url}`);
  }
  const json=await response.json();
  dataCache.set(key,json);
  return json;
}

function loadOrgList(){
  if(orgListPromise){
    return orgListPromise;
  }
  if(INLINE_ORGS){
    orgListPromise=Promise.resolve(INLINE_ORGS);
  }else{
    orgListPromise=fetch("./orgs.json").then(r=>r.ok?r.json():[]).catch(()=>[]);
  }
  return orgListPromise;
}

function applyData(json,orgList){
  const sourceData=Array.isArray(json)?json.slice():[];
  const sourceOrgList=Array.isArray(orgList)?orgList.slice():[];
  orgMeta.clear();
  if(Array.isArray(sourceOrgList)){
    sourceOrgList.forEach(entry=>{
      if(entry&&entry.id){
        const regionText=typeof entry.region==="string"?entry.region.trim():null;
        preloadLogo(entry.logo);
        orgMeta.set(entry.id,{
          color:entry.color||null,
          logo:entry.logo||null,
          company:entry.company===true,
          region:regionText,
          regionKey:normalizeRegionKey(regionText)
        });
      }
    });
  }
  const grouped=d3.groups(sourceData,d=>d.id).map(([id,arr])=>{
    arr.sort((a,b)=>+a.week_count-+b.week_count);
    const enriched=arr.map(entry=>{
      const weekDate=parseDateYYYYMMDD(entry.week_date);
      const monthDate=parseDateYYYYMMDD(entry.month_date);
      return {...entry, __weekDate:weekDate, __monthDate:monthDate, __date:weekDate||null};
    });
    return {id, values:enriched};
  });
  rawById=grouped;
  const ids=rawById.map(s=>s.id);
  const previousActive=active instanceof Map?active:new Map();
  const nextActive=new Map();
  ids.forEach(id=>{
    let shouldBeActive=true;
    if(inlineActiveIdSet){
      shouldBeActive=inlineActiveIdSet.has(id);
    }else if(previousActive.has(id)){
      shouldBeActive=previousActive.get(id);
    }
    nextActive.set(id,shouldBeActive);
  });
  inlineActiveIdSet=null;
  active=nextActive;
  colorScale.domain(ids);
  const defaultMetric=METRICS.length?METRICS[0].key:null;
  let filterMetric=currentFilter.metric;
  if(!filterMetric||(filterMetric!=="downloads_per_repo"&&!METRICS.some(m=>m.key===filterMetric))){
    filterMetric=defaultMetric;
  }
  currentFilter={ percent:clampFilterPercent(currentFilter.percent), metric:filterMetric };
  setRegionFilter(currentRegionFilter,{ force:true, skipConfig:true, skipRender:true });
  setOrgFilter(currentOrgFilter,{ force:true, skipConfig:true, skipRender:true });
  updateAxisLabel();
  if(window.ConfigTab&&typeof window.ConfigTab.setMetrics==="function"){ window.ConfigTab.setMetrics(METRICS,currentMetric); }
  if(window.ConfigTab&&typeof window.ConfigTab.setScale==="function"){ window.ConfigTab.setScale(currentScale); }
  if(window.ConfigTab&&typeof window.ConfigTab.setModeDisabled==="function"){ window.ConfigTab.setModeDisabled(currentScale==="normalized"); }
  if(window.ConfigTab&&typeof window.ConfigTab.setNormModeVisible==="function"){ window.ConfigTab.setNormModeVisible(currentScale==="normalized"); }
  if(window.ConfigTab&&typeof window.ConfigTab.setNormMode==="function"){ window.ConfigTab.setNormMode(currentNormMode); }
  if(window.ConfigTab&&typeof window.ConfigTab.setSliderVisible==="function"){ window.ConfigTab.setSliderVisible(sliderVisible); }
  if(window.ConfigTab&&typeof window.ConfigTab.setTitleVisible==="function"){ window.ConfigTab.setTitleVisible(titleVisible); }
  if(window.ConfigTab&&typeof window.ConfigTab.setTopFilter==="function"){ window.ConfigTab.setTopFilter(currentFilter); }
  if(window.ConfigTab&&typeof window.ConfigTab.setSliderVisible==="function"){ window.ConfigTab.setSliderVisible(sliderVisible); }
  if(window.ConfigTab&&typeof window.ConfigTab.setTitleVisible==="function"){ window.ConfigTab.setTitleVisible(titleVisible); }
  if(window.ConfigTab&&typeof window.ConfigTab.setOrgFilter==="function"){ window.ConfigTab.setOrgFilter(currentOrgFilter); }
  if(window.ConfigTab&&typeof window.ConfigTab.setRegionFilter==="function"){ window.ConfigTab.setRegionFilter(currentRegionFilter); }
  if(window.ConfigTab&&typeof window.ConfigTab.setMinSpaces==="function"){ window.ConfigTab.setMinSpaces(currentMinSpaces); }
  if(window.ConfigTab&&typeof window.ConfigTab.setMinDownloads==="function"){ window.ConfigTab.setMinDownloads(currentMinDownloads); }
  buildSeriesFromRaw();
  render();
}

async function load(){
  const requestId=++dataLoadToken;
  try{
    const [json,orgList]=await Promise.all([
      fetchDataSource(currentMinSpaces,currentMinDownloads),
      loadOrgList()
    ]);
    if(requestId!==dataLoadToken){
      return;
    }
    applyData(json,orgList);
  }catch(err){
    if(requestId!==dataLoadToken){
      return;
    }
    console.error("Failed to load visualization data:",err);
    orgMeta.clear();
    rawById=[];
    series=[];
    currentTimeline=[];
    legendFullIds=[];
    legendCurrentIds=[];
    syncRangeWithTimeline();
    render();
  }
}

if(downloadButton){
  downloadButton.addEventListener("click",handleDownloadClick);
}

loadSlider();
if(!IS_EXPORT_MODE){
  loadConfigTab();
}
load();
window.addEventListener("resize",function(){ render(); });
const vizEl=document.getElementById("viz");
if(typeof ResizeObserver!=="undefined"&&vizEl){
  const chartObserver=new ResizeObserver(function(){ render(); });
  chartObserver.observe(vizEl);
}
</script>
</body>
</html>
