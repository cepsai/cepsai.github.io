<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Trading Models Performance</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
html, body { height: 100%; }
body { margin: 0; overflow: hidden; background: #ffffff; color: #111; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, sans-serif; height: 100vh; }
.viz-layout { position: relative; width: 100%; height: 100vh; display: flex; align-items: stretch; justify-content: flex-start; overflow: hidden; min-width: 0; }
.viz-grid { display: grid; grid-template-rows: 1fr auto auto; grid-template-columns: 1fr 1fr; height: 100vh; width: 100vw; box-sizing: border-box; row-gap: clamp(6px, 1.5vh, 12px); padding: 0 clamp(12px, 2vw, 20px) env(safe-area-inset-bottom) clamp(12px, 2vw, 20px); }
#container1 { grid-row: 1; grid-column: 1 / span 2; display: flex; overflow: hidden; min-height: 0; column-gap: 0; padding: 0; }
#container2 { grid-row: 2; grid-column: 1 / span 2; display: flex; align-items: center; justify-content: center; gap: clamp(12px, 2vw, 20px); min-width: 0; padding: clamp(4px, 0.5vh, 8px) 0; position: relative; }
#container3 { grid-row: 3; grid-column: 1; display: flex; align-items: center; justify-content: flex-start; min-width: 0; }
#container4 { grid-row: 3; grid-column: 2; display: flex; align-items: center; justify-content: flex-end; gap: clamp(10px, 2vw, 16px); min-width: 0; }
.source-text { font-size: clamp(10px, 1.6vw, 16px); font-weight: 600; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; font-style: normal; }
.source-text a { color: #2756d3; text-decoration: underline; cursor: pointer; }
.source-text a:visited { color: #2756d3; }
.logo-note { font-size: clamp(8px, 1vw, 12px); color: #777; font-style: italic; white-space: nowrap; position: absolute; right: 0; }
.logo { height: 100%; width: auto; max-height: 100%; max-width: 100%; pointer-events: auto; object-fit: contain; }
.y-axis-container { flex: 0 0 clamp(28px, 3vw, 46px); display: flex; align-items: center; justify-content: flex-end; min-width: 0; border-right: 1px solid rgba(0, 0, 0, 0.1); box-sizing: border-box; padding: 0 6px; }
.y-axis-label { writing-mode: vertical-rl; transform: rotate(180deg); text-align: center; font-weight: 600; font-size: clamp(10px, 1.2vw, 16px); color: #333; line-height: 1.2; letter-spacing: 0.04em; }
.chart-wrapper { flex: 1 1 auto; display: flex; min-width: 0; height: 100%; margin-left: -6px; }
.chart-wrapper-inner { flex: 1 1 auto; display: flex; min-width: 0; height: 100%; }
#viz { position: relative; width: 100%; height: 100%; min-width: 0; min-height: 0; display: flex; align-items: center; justify-content: center; }
#chart { display: block; width: 100%; height: 100%; }
#tooltip { position: absolute; background: #fff; border: 1px solid #d9d9df; border-radius: 6px; padding: 6px 8px; font-size: 12px; pointer-events: none; opacity: 0; box-shadow: 0 4px 14px rgba(0, 0, 0, 0.08); transition: opacity .12s ease; max-width: 220px; }
.axis path, .axis line { stroke: #cfd2d7; }
.axis text { fill: #333; font-size: 12px; }
.x-axis text { font-size: clamp(12px, 1.2vw, 18px); }
.grid line { stroke: rgba(230, 232, 239, 0.45); }
.grid .domain { display: none; }
.final-node { cursor: pointer; }
.reference-line-label { font-size: 11px; fill: #666; font-weight: 600; }
.day-display { font-weight: 600; color: #26344f; font-size: clamp(16px, 2vw, 22px); line-height: 1.2; }
.date-display { display: inline-flex; align-items: center; justify-content: center; padding: 6px 12px; border: 1px solid #cfd2d7; border-radius: 10px; background: rgba(255,255,255,.92); font-weight: 700; color: #26344f; font-size: clamp(12px, 1.4vw, 16px); line-height: 1; min-width: clamp(160px, 20vw, 220px); width: clamp(160px, 20vw, 220px); box-sizing: border-box; }
@media (max-width: 860px) { .logo-note { font-size: clamp(7px, 0.9vw, 10px); } }
@media (max-width: 640px) { #container3 { display: none; } .logo-note { display: none; } }
@media (max-width: 460px), (max-height: 520px) { #container2 { display: none; } }
@media (max-height: 480px) { .viz-grid { grid-template-rows: 1fr; } #container2, #container3, #container4 { display: none; } }
</style>
</head>
<body>
<div class="viz-layout" id="vizLayout">
  <div class="viz-grid">
    <div id="container1" class="container chart-container">
      <div class="y-axis-container">
        <div class="y-axis-label" id="yLabel">Portfolio Value ($)</div>
      </div>
      <div class="chart-wrapper">
        <div class="chart-wrapper-inner">
          <div id="viz">
            <svg id="chart" role="img"></svg>
            <div id="tooltip"></div>
          </div>
        </div>
      </div>
    </div>
    <div id="container2" class="container note-container">
      <div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
        <div id="dayDisplay" class="day-display"></div>
        <div id="dateDisplay" class="date-display"></div>
      </div>
    </div>
    <div id="container3" class="container source-container">
      <div class="source-text">Source: <a href="https://nof1.ai/" target="_blank">nof1.ai</a></div>
      <img src="./nof1.png" alt="nof1 logo" style="height: 24px; margin-left: 8px; object-fit: contain;">
    </div>
    <div id="container4" class="container logo-container">
      <a href="https://aiworld.eu/" target="_blank" rel="noopener">
        <img src="logo.svg" class="logo" alt="AI World logo" crossorigin="anonymous">
      </a>
    </div>
  </div>
</div>

<script>
const svg = d3.select("#chart");
const tooltip = d3.select("#tooltip");
const yLabelEl = document.getElementById("yLabel");
const vizEl = document.getElementById("viz");
const dateDisplayEl = document.getElementById("dateDisplay");
const dayDisplayEl = document.getElementById("dayDisplay");
const REFERENCE_LINE_VALUE = 10000;
const INCLUDED_PERCENT = 100;
const METRIC = { key: "money", label: "Portfolio Value ($)" };
const STEP_MIN = 1;
const STEP_MAX = 16;
const DELAY_MIN = 60;
const DELAY_MAX = 4000;
const REPLAY_DELAY = 4000;
let autoStep = 2;
let autoDelay = 80;
const colorScale = d3.scaleOrdinal(d3.schemeTableau10);
const formatComma = d3.format(",.0f");
const formatMoney = d => "$" + d3.format(",.0f")(d);
let modelMeta = new Map();
let chartSeries = [];
let timelineSteps = [];
let xScale = null;
let yScale = null;
let lineGenerator = null;
let currentStart = 0;
let currentEnd = 0;
let autoTimer = null;
let replayTimeout = null;
let animDefaultStart = 0;
let animDefaultEnd = 0;
let animWindowSize = 1;
let animTargetEnd = 0;
let highestPoint = null;
let highestPointShown = false;
let slowdownSteps = 0;
let pauseSteps = 0;
let lowestPoint = null;
let lowestPointShown = false;

init();

async function init(){
  try{
    const [rawData, llms] = await Promise.all([
      fetchCSV("./data.csv"),
      fetchJSON("./llms.json")
    ]);
    modelMeta = buildModelMeta(llms);
    const processed = buildSeriesFromCSV(rawData);
    chartSeries = processed.series;
    timelineSteps = processed.timeline;
    yLabelEl.textContent = METRIC.label;
    render();
    setupAnimation();
    bindSpeedKeys();
  }catch(err){
    console.error("Failed to load visualization data:", err);
  }
}

async function fetchCSV(url){
  const response = await fetch(url);
  if(!response.ok){ throw new Error(`HTTP ${response.status} while fetching ${url}`); }
  const text = await response.text();
  return d3.csvParse(text);
}

async function fetchJSON(url){
  const response = await fetch(url);
  if(!response.ok){ throw new Error(`HTTP ${response.status} while fetching ${url}`); }
  return response.json();
}

function buildModelMeta(list){
  const map = new Map();
  if(Array.isArray(list)){
    list.forEach(item=>{
      if(!item || !item.id){ return; }
      map.set(item.id, { ...item });
    });
  }
  return map;
}

function buildSeriesFromCSV(rawData){
  if(!Array.isArray(rawData)){ return { series: [], timeline: [] }; }

  const groups = d3.group(rawData.filter(d => d.model !== "buynhold_btc"), d => d.model);

  const allTimestamps = [...new Set(rawData.map(d => +d.timestamp))].sort((a, b) => a - b);
  const timeline = allTimestamps;

  const series = [];
  groups.forEach((entries, modelName)=>{
    const values = entries.map(entry=>{
      const timestamp = +entry.timestamp;
      const money = +entry.money;
      return {
        id: modelName,
        timestamp,
        end: Number.isFinite(money) ? money : 0,
        index: allTimestamps.indexOf(timestamp)
      };
    });

    values.sort((a, b) => a.timestamp - b.timestamp);

    for(let k = 1; k < values.length; k++){
      values[k].delta = values[k].end - values[k - 1].end;
    }
    if(values.length > 0) values[0].delta = 0;

    const finalValue = values.length ? values[values.length - 1].end : 0;
    series.push({ id: modelName, values, finalValue });
  });

  series.sort((a, b) => (b.finalValue || 0) - (a.finalValue || 0));

  let maxValue = -Infinity;
  let maxPoint = null;
  let minValue = Infinity;
  let minPoint = null;
  series.forEach(s => {
    s.values.forEach(v => {
      if (v.end > maxValue) {
        maxValue = v.end;
        maxPoint = { ...v, seriesId: s.id };
      }
      if (v.end < minValue) {
        minValue = v.end;
        minPoint = { ...v, seriesId: s.id };
      }
    });
  });
  highestPoint = maxPoint;
  lowestPoint = minPoint;

  return { series, timeline };
}

function getModelColor(id){
  const meta = modelMeta.get(id);
  if(meta && meta.color){ return meta.color; }
  return colorScale(id);
}

function getModelLogo(id){
  const meta = modelMeta.get(id);
  return meta && meta.logo ? meta.logo : null;
}

function formatValue(value){
  if(!Number.isFinite(value)){ return "$0"; }
  return formatMoney(value);
}

function getTimestepTickStep(innerW){
  if(innerW < 360){ return Math.ceil(timelineSteps.length / 4); }
  if(innerW < 680){ return Math.ceil(timelineSteps.length / 8); }
  if(innerW < 900){ return Math.ceil(timelineSteps.length / 12); }
  return Math.ceil(timelineSteps.length / 16);
}

function render(){
  if(!chartSeries.length){
    svg.selectAll("*").remove();
    return;
  }
  const margin = { top: 32, right: 40, bottom: 56, left: 74 };
  const rect = vizEl.getBoundingClientRect();
  const width = Math.max(margin.left + margin.right + 360, rect.width || 960);
  const height = Math.max(margin.top + margin.bottom + 280, rect.height || 560);
  svg.attr("viewBox", `0 0 ${width} ${height}`);
  svg.attr("aria-label", `${METRIC.label} line chart`);
  const defs = svg.selectAll("defs").data([null]).join("defs");
  const logoClip = defs.selectAll("clipPath#logoCircleClip").data([null]).join("clipPath").attr("id", "logoCircleClip").attr("clipPathUnits", "objectBoundingBox");
  logoClip.selectAll("circle").data([null]).join("circle").attr("cx", 0.5).attr("cy", 0.5).attr("r", 0.5);
  const root = svg.selectAll("g.chart-root").data([null]).join("g").attr("class", "chart-root").attr("transform", `translate(${margin.left},${margin.top})`);
  const allTimestamps = timelineSteps.length ? timelineSteps : chartSeries.flatMap(s => s.values.map(p => p.timestamp));
  if(!allTimestamps.length){
    svg.selectAll("*").remove();
    return;
  }
  let xDomain = d3.extent(allTimestamps);
  if(!xDomain[0] && xDomain[0] !== 0 || !xDomain[1] && xDomain[1] !== 0 || xDomain[0] === xDomain[1]){
    xDomain = [0, 1];
  }
  const valuesFlat = chartSeries.flatMap(s => s.values.map(p => p.end));
  const yMax = 25000; // Fixed y-axis to $25K
  xScale = d3.scaleLinear().domain(xDomain).range([0, Math.max(120, width - margin.left - margin.right)]);
  yScale = d3.scaleLinear().domain([0, yMax]).range([Math.max(120, height - margin.top - margin.bottom), 0]);
  const innerW = xScale.range()[1];
  const isTiny = innerW < 420;
  const compact = innerW < 720 && !isTiny;
  const dotR = isTiny ? Math.max(1, Math.min(3, Math.round(innerW / 360))) : compact ? Math.round(Math.max(2, Math.min(4, innerW / 300))) : Math.round(Math.max(3, Math.min(6, innerW / 250)));
  const xTickStep = getTimestepTickStep(innerW);
  const xAxis = d3.axisBottom(xScale).ticks(0).tickFormat(() => ""); // Hide x-axis labels
  const yAxis = d3.axisLeft(yScale).ticks(6).tickFormat(formatValue);
  const grid = root.selectAll("g.grid-y").data([null]).join("g").attr("class", "grid grid-y").call(d3.axisLeft(yScale).ticks(6).tickSize(-xScale.range()[1]).tickFormat(""));
  grid.select(".domain").remove();
  grid.selectAll("line").attr("stroke", "rgba(230,232,239,0.45)");

  // Add reference line for $10K
  const refLine = root.selectAll("line.reference-line").data([REFERENCE_LINE_VALUE]).join("line").attr("class", "reference-line").attr("x1", 0).attr("x2", xScale.range()[1]).attr("y1", d => yScale(d)).attr("y2", d => yScale(d)).attr("stroke", "#999").attr("stroke-width", 2).attr("stroke-dasharray", "5,5").attr("opacity", 0.7);

  // Add label for reference line
  const refLabel = root.selectAll("text.reference-line-label").data([REFERENCE_LINE_VALUE]).join("text").attr("class", "reference-line-label").attr("x", xScale.range()[1] - 5).attr("y", d => yScale(d) - 5).attr("text-anchor", "end").text("$10K");

  // Add highest point marker group
  const highestMarker = root.selectAll("g.highest-marker").data([null]).join("g").attr("class", "highest-marker").style("display", "none").style("opacity", 0);
  highestMarker.selectAll("line.highest-line").data([null]).join("line").attr("class", "highest-line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", -20).attr("stroke", "#888").attr("stroke-width", 1.5).attr("stroke-dasharray", "3,3");
  highestMarker.selectAll("text.highest-label").data([null]).join("text").attr("class", "highest-label").attr("dy", -24).attr("text-anchor", "start").attr("dx", 5).attr("font-size", "11px").attr("font-weight", "600").attr("fill", "#666").text("Highest point");
  highestMarker.selectAll("text.highest-value").data([null]).join("text").attr("class", "highest-value").attr("dy", -24).attr("text-anchor", "end").attr("dx", -5).attr("font-size", "12px").attr("font-weight", "700").attr("fill", "#22c55e");

  // Add lowest point marker group
  const lowestMarker = root.selectAll("g.lowest-marker").data([null]).join("g").attr("class", "lowest-marker").style("display", "none").style("opacity", 0);
  lowestMarker.selectAll("line.lowest-line").data([null]).join("line").attr("class", "lowest-line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 20).attr("stroke", "#888").attr("stroke-width", 1.5).attr("stroke-dasharray", "3,3");
  lowestMarker.selectAll("text.lowest-label").data([null]).join("text").attr("class", "lowest-label").attr("dy", 32).attr("text-anchor", "start").attr("dx", 5).attr("font-size", "11px").attr("font-weight", "600").attr("fill", "#666").text("Lowest point");
  lowestMarker.selectAll("text.lowest-value").data([null]).join("text").attr("class", "lowest-value").attr("dy", 32).attr("text-anchor", "end").attr("dx", -5).attr("font-size", "12px").attr("font-weight", "700").attr("fill", "#ef4444");

  const xAxisGroup = root.selectAll("g.x-axis").data([null]).join("g").attr("class", "axis x-axis").attr("transform", `translate(0,${yScale.range()[0]})`).call(xAxis);
  const yAxisGroup = root.selectAll("g.y-axis").data([null]).join("g").attr("class", "axis y-axis").call(yAxis);
  yAxisGroup.select(".domain").remove();
  xAxisGroup.select(".domain").attr("stroke", "#cfd2d7");
  lineGenerator = d3.line().defined(point => Number.isFinite(point.end)).x(point => xScale(point.timestamp)).y(point => yScale(point.end));
  const seriesGroups = root.selectAll("g.series-group").data(chartSeries, d => d.id);
  const seriesEnter = seriesGroups.enter().append("g").attr("class", "series-group");
  seriesEnter.append("path").attr("class", "series-line").attr("fill", "none").attr("stroke-width", 2);
  seriesEnter.append("g").attr("class", "series-dots");
  const finalNode = seriesEnter.append("g").attr("class", "final-node");
  finalNode.append("circle").attr("class", "final-outline");
  finalNode.append("image").attr("class", "final-logo");
  const seriesMerged = seriesEnter.merge(seriesGroups);
  seriesMerged.each(function(series){
    d3.select(this).select("path.series-line").attr("stroke", getModelColor(series.id));
    d3.select(this).select("g.series-dots").attr("data-dot-r", dotR);
  });
  seriesGroups.exit().remove();
  updateFrameRange(currentStart, currentEnd);
}

function updateFrameRange(startIndex, endIndex){
  if(!chartSeries.length || !timelineSteps.length || !xScale || !yScale || !lineGenerator){ return; }
  currentStart = 0;
  currentEnd = Math.max(0, Math.min(endIndex, timelineSteps.length - 1));
  const root = svg.select("g.chart-root");
  const innerWidth = xScale.range()[1];
  const isTinyW = innerWidth < 420;
  const compact = innerWidth < 720 && !isTinyW;
  const logoSize = isTinyW ? Math.round(Math.max(14, Math.min(22, innerWidth / 40))) : compact ? Math.round(Math.max(16, Math.min(28, innerWidth / 36))) : Math.round(Math.max(22, Math.min(42, innerWidth / 26)));
  const r = Math.round(logoSize / 2 + 2);
  const recomputedDotR = (()=>{ if(isTinyW){ return Math.max(1, Math.min(3, Math.round(innerWidth / 360))); } if(compact){ return Math.round(Math.max(2, Math.min(4, innerWidth / 300))); } return Math.round(Math.max(3, Math.min(6, innerWidth / 250))); })();
  const xTickStep = getTimestepTickStep(innerWidth);
  const domainStartTimestamp = timelineSteps[0];
  const domainEndTimestamp = timelineSteps[currentEnd];
  xScale.domain([domainStartTimestamp, domainEndTimestamp]);
  const xAxis = d3.axisBottom(xScale).ticks(0).tickFormat(() => "");
  root.select("g.x-axis").attr("transform", `translate(0,${yScale.range()[0]})`).call(xAxis);
  root.select("g.x-axis .domain").attr("stroke", "#cfd2d7");

  const valuesById = new Map();
  chartSeries.forEach(s=>{
    const vis = s.values.filter(v => v.index >= 0 && v.index <= currentEnd);
    valuesById.set(s.id, { values: vis, last: vis[vis.length - 1] || null });
  });

  yScale.domain([0, 25000]);
  const yAxis = d3.axisLeft(yScale).ticks(6).tickFormat(formatValue);
  root.select("g.y-axis").call(yAxis);
  const gridCall = d3.axisLeft(yScale).ticks(6).tickSize(-xScale.range()[1]).tickFormat("");
  const grid = root.select("g.grid-y").call(gridCall);
  grid.select(".domain").remove();
  grid.selectAll("line").attr("stroke", "rgba(230,232,239,0.45)");


  root.selectAll("line.reference-line").attr("x2", xScale.range()[1]).attr("y1", yScale(REFERENCE_LINE_VALUE)).attr("y2", yScale(REFERENCE_LINE_VALUE));
  root.selectAll("text.reference-line-label").attr("x", xScale.range()[1] - 5).attr("y", yScale(REFERENCE_LINE_VALUE) - 5);

  const highestMarker = root.select("g.highest-marker");
  if (highestPoint && currentEnd >= highestPoint.index) {
    const hx = xScale(highestPoint.timestamp);
    const hy = yScale(highestPoint.end);
    highestMarker.style("display", null)
      .attr("transform", `translate(${hx},${hy})`)
      .raise();

    // Update value text
    highestMarker.select("text.highest-value").text(formatValue(highestPoint.end));

    if (!highestPointShown) {
      highestMarker.transition()
        .duration(800)
        .ease(d3.easeCubicOut)
        .style("opacity", 1);
      highestPointShown = true;
    } else {
      highestMarker.style("opacity", 1);
    }
  } else {
    highestMarker.style("display", "none").style("opacity", 0);
  }

  const lowestMarker = root.select("g.lowest-marker");
  if (lowestPoint && currentEnd >= lowestPoint.index) {
    const lx = xScale(lowestPoint.timestamp);
    const ly = yScale(lowestPoint.end);
    lowestMarker.style("display", null)
      .attr("transform", `translate(${lx},${ly})`)
      .raise();

    // Update value text
    lowestMarker.select("text.lowest-value").text(formatValue(lowestPoint.end));

    if (!lowestPointShown) {
      lowestMarker.transition()
        .duration(800)
        .ease(d3.easeCubicOut)
        .style("opacity", 1);
      lowestPointShown = true;
    } else {
      lowestMarker.style("opacity", 1);
    }
  } else {
    lowestMarker.style("display", "none").style("opacity", 0);
  }

  const seriesMerged = root.selectAll("g.series-group");
  seriesMerged.each(function(series){
    const rec = valuesById.get(series.id) || { values: [], last: null };
    const drawValues = rec.values;
    d3.select(this).select("path.series-line").attr("d", lineGenerator(drawValues));

    d3.select(this).select("g.series-dots").selectAll("circle.dot").remove();

    const lastPoint = rec.last;
    const node = d3.select(this).select("g.final-node");
    if(lastPoint){
      const cx = xScale(lastPoint.timestamp);
      const cy = yScale(lastPoint.end);
      const logoUrl = getModelLogo(series.id) || "";
      const modelColor = getModelColor(series.id);
      node.raise();
      node.style("display", null);
      node.select("circle.final-outline").attr("cx", cx).attr("cy", cy).attr("r", r).attr("fill", modelColor).attr("stroke", modelColor).attr("stroke-width", 2);
      node.select("image.final-logo").attr("href", logoUrl).attr("x", cx - logoSize / 2).attr("y", cy - logoSize / 2).attr("width", logoSize).attr("height", logoSize).attr("preserveAspectRatio", "xMidYMid slice").attr("clip-path", "url(#logoCircleClip)");
      node.style("pointer-events", "all").on("mouseenter", (event)=>{ showTooltip(event, { ...lastPoint, seriesId: series.id }); }).on("mousemove", (event)=>{ moveTooltip(event, { ...lastPoint, seriesId: series.id }); }).on("mouseleave", ()=>{ hideTooltip(); });
    }else{
      node.style("display", "none");
    }
  });
  updateTimestepUI();
}

function showTooltip(event, point){
  tooltip.style("opacity", 1);
  moveTooltip(event, point);
}

function moveTooltip(event, point){
  const [x, y] = d3.pointer(event, vizEl);
  let timestepText = "Hour 0";
  if(Number.isFinite(point.timestamp)){
    timestepText = `Hour ${point.timestamp}`;
  }
  const deltaText = Number.isFinite(point.delta) ? formatValue(point.delta) : "$0";
  tooltip.html(`<strong>${point.id}</strong><br>${timestepText}<br>Value: ${formatValue(point.end)}<br>Change: ${deltaText}`);
  const ttNode = tooltip.node();
  const ttWidth = ttNode ? ttNode.offsetWidth : 0;
  const left = Math.max(6, x - ttWidth - 14);
  const top = Math.max(6, y - 28);
  tooltip.style("left", `${left}px`);
  tooltip.style("top", `${top}px`);
}

function hideTooltip(){ tooltip.style("opacity", 0); }

function updateTimestepUI(){
  if(!timelineSteps.length || !dateDisplayEl || !dayDisplayEl){ return; }
  const idx = Math.max(0, Math.min(currentEnd, timelineSteps.length - 1));
  const hour = timelineSteps[idx];

  const startDate = new Date(2024, 9, 18, 0, 0, 0);
  const currentDate = new Date(startDate.getTime() + hour * 60 * 60 * 1000);

  const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  const dateStr = `${monthNames[currentDate.getMonth()]} ${currentDate.getDate()}`;

  dayDisplayEl.textContent = dateStr;
  dateDisplayEl.textContent = `Hour ${hour}`;
}

function setupAnimation(){
  if(!timelineSteps.length){ return; }
  animDefaultStart = 0;
  animDefaultEnd = 0;
  currentEnd = 0;
  currentStart = 0;
  animTargetEnd = timelineSteps.length - 1;
  highestPointShown = false;
  lowestPointShown = false;
  slowdownSteps = 0;
  pauseSteps = 0;
  updateFrameRange(currentStart, currentEnd);
  startTimer();
}

function tick(){
  const hardStop = Math.min(animTargetEnd, timelineSteps.length - 1);
  if(currentEnd >= hardStop){
    stopTimer();
    if(replayTimeout){ window.clearTimeout(replayTimeout); }
    replayTimeout = window.setTimeout(()=>{
      currentEnd = 0;
      currentStart = 0;
      highestPointShown = false;
      lowestPointShown = false;
      slowdownSteps = 0;
      pauseSteps = 0;
      updateFrameRange(currentStart, currentEnd);
      startTimer();
    }, REPLAY_DELAY);
    return;
  }

  let currentDelay = autoDelay;

  if (highestPoint && !highestPointShown && currentEnd + 1 >= highestPoint.index && currentEnd < highestPoint.index) {
    slowdownSteps = 3;
  }

  if (slowdownSteps > 0) {
    currentDelay = autoDelay * 3;
    slowdownSteps--;
  }

  if (highestPointShown && pauseSteps > 0) {
    currentDelay = autoDelay * 3;
    pauseSteps--;
  }

  currentEnd = Math.min(hardStop, currentEnd + 1);
  updateFrameRange(currentStart, currentEnd);

  if (highestPoint && currentEnd === highestPoint.index && !highestPointShown) {
    pauseSteps = 10;
  }

  stopTimer();
  autoTimer = window.setInterval(tick, currentDelay);
}

function startTimer(){
  stopTimer();
  autoTimer = window.setInterval(tick, autoDelay);
}

function stopTimer(){
  if(autoTimer){ window.clearInterval(autoTimer); autoTimer = null; }
}

function restartTimerIfPlaying(){
  if(autoTimer){ startTimer(); }
}

function setAutoStep(n){
  const v = Math.max(STEP_MIN, Math.min(STEP_MAX, Math.round(n)));
  autoStep = v;
  restartTimerIfPlaying();
}

function setAutoDelay(ms){
  const v = Math.max(DELAY_MIN, Math.min(DELAY_MAX, Math.round(ms)));
  autoDelay = v;
  restartTimerIfPlaying();
}

function bindSpeedKeys(){
  window.addEventListener("keydown", e=>{
    if(e.key === "-" || e.key === "_"){ setAutoDelay(autoDelay + 150); }
    else if(e.key === "=" || e.key === "+"){ setAutoDelay(autoDelay - 120); }
    else if(e.key === "["){ setAutoStep(autoStep - 1); }
    else if(e.key === "]"){ setAutoStep(autoStep + 1); }
  });
  window.AnimationSpeed = { setAutoStep, setAutoDelay };
}

if(typeof ResizeObserver !== "undefined" && vizEl){
  const chartObserver = new ResizeObserver(()=>{ render(); updateFrameRange(currentStart, currentEnd); });
  chartObserver.observe(vizEl);
}
window.addEventListener("resize", ()=>{ render(); updateFrameRange(currentStart, currentEnd); });
svg.on("mouseleave", hideTooltip);
</script>
</body>
</html>