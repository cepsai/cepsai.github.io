<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <style type="text/css">
    .knitr .inline {
      background-color: #F7F7F7;
      border: solid 1px #B0B0B0;
    }

    .error {
      font-weight: bold;
      color: #FF0000;
    }

    .warning {
      font-weight: bold;
    }

    .message {
      font-style: italic;
    }

    .source,
    .output,
    .warning,
    .error,
    .message {
      padding: 0 1em;
      border: solid 1px #F7F7F7;
    }

    .source {
      background-color: #F5F5F5;
    }

    .rimage .left {
      text-align: left;
    }

    .rimage .right {
      text-align: right;
    }

    .rimage .center {
      text-align: center;
    }

    body {
      margin: 0;
      overflow: hidden;
      height: 100vh;
      font-family: Arial, sans-serif;
      background-color: white;
    }

    .viz-grid {
      display: grid;
      grid-template-rows: 16fr 1fr 2fr 1fr;
      grid-template-columns: 1fr 1fr;
      height: 100vh;
      width: 100vw;
      box-sizing: border-box;
      padding-bottom: clamp(8px, 2vh, 18px);
    }

    #container1 {
      grid-row: 1;
      grid-column: 1 / span 2;
      overflow: hidden;
      min-height: 0;
    }

    #container5 {
      grid-row: 2;
      grid-column: 1 / span 2;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding: 0 20px;
      overflow: hidden;
    }

    #container2 {
      grid-row: 3;
      grid-column: 1 / span 2;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #container3 {
      grid-row: 4;
      grid-column: 1;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 0 20px;
      overflow: hidden;
      min-width: 0;
    }

    #container4 {
      grid-row: 4;
      grid-column: 2;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding: 0 20px;
      overflow: hidden;
      min-width: 0;
    }

    #container4 a {
      height: 100%;
      display: flex;
      align-items: center;
    }

    #viz {
      width: 100%;
      height: 100%;
      min-height: 0;
      min-width: 0;
    }

    .custom-legend {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: clamp(4px, 1vw, 10px);
      padding: clamp(2px, 0.5vh, 4px) clamp(4px, 0.8vw, 8px);
      overflow: auto;
      max-width: 100%;
      max-height: 100%;
      font-size: clamp(8px, 1.3vw, 13px);
      font-weight: 600;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: opacity 0.2s ease;
      font-weight: 600;
      color: #333;
      position: relative;
    }

    .legend-item.inactive {
      opacity: 0.35;
    }

    .legend-square {
      width: clamp(10px, 1.2vw, 14px);
      height: clamp(10px, 1.2vw, 14px);
      border-radius: 4px;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.15) inset;
    }

    .legend-item:focus-visible {
      outline: 2px solid rgba(0, 0, 0, 0.5);
      outline-offset: 2px;
    }

    .logo {
      height: 100%;
      width: auto;
      max-height: 100%;
      max-width: 100%;
      pointer-events: auto;
      object-fit: contain;
    }

    .source-text {
      font-size: clamp(10px, 1.6vw, 16px);
      font-weight: 600;
      color: #333;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
      font-style: normal;
    }

    .source-text a {
      color: #2756d3;
      text-decoration: underline;
      cursor: pointer;
      font-style: normal;
    }

    .source-text a:visited {
      color: #2756d3;
    }

    .footnote-text {
      font-size: clamp(10px, 1.6vw, 16px);
      font-style: italic;
      color: #333;
      text-align: right;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }


    @media (max-height: 500px) {
      .viz-grid {
        grid-template-rows: 1fr;
        grid-template-columns: 1fr;
      }

      #container1 {
        grid-row: 1;
        grid-column: 1;
      }

      #container2,
      #container3,
      #container4,
      #container5 {
        display: none !important;
      }

      .custom-legend,
      .source-text,
      .logo,
      .footnote-text {
        display: none !important;
      }
    }
  </style>

  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3plus-hierarchy@1"></script>
</head>

<body>
  <div class="viz-grid">
    <div id="container1" class="container viz-container">
      <div id="viz"></div>
    </div>
    <div id="container5" class="container footnote-container">
      <div class="footnote-text" id="footnote-text">
        This is a footnote example
      </div>
    </div>
    <div id="container2" class="container legend-container">
      <div class="custom-legend" id="legend"></div>
    </div>
    <div id="container3" class="container source-container">
      <div class="source-text" id="source-text">
    Source: <a href="https://huggingface.co/spaces/AIEnergyScore/Leaderboard" target="_blank" rel="noopener noreferrer">AI Energy Score Leaderboard</a>
  </div>
    </div>
    <div id="container4" class="container logo-container">
      <a href="https://aiworld.eu/" id="logo-link" target="_blank" rel="noopener">
        <img src="https://aiworld.eu/logo-transparent.svg" class="logo" alt="AI World logo" />
      </a>
    </div>
  </div>

  <script>
    const SHOW_CONTAINER_2 = 0;
    const SHOW_CONTAINER_3 = 1;
    const SHOW_CONTAINER_4 = 1;
    const SHOW_CONTAINER_5 = 0;

    const VIZ_CONTAINER_ID = 'viz';
    const SOURCE_CONTAINER_ID = 'source-text';
    const LOGO_CONTAINER_ID = 'logo-link';
    const FOOTNOTE_CONTAINER_ID = 'footnote-text';

    const vizContainer = document.getElementById(VIZ_CONTAINER_ID);
    const sourceContainer = document.getElementById(SOURCE_CONTAINER_ID);
    const logoContainer = document.getElementById(LOGO_CONTAINER_ID);
    const footnoteContainer = document.getElementById(FOOTNOTE_CONTAINER_ID);

    (function applyContainerVisibility() {
      const vizGrid = document.querySelector('.viz-grid');
      const container1 = document.getElementById('container1');
      const container2 = document.getElementById('container2');
      const container3 = document.getElementById('container3');
      const container4 = document.getElementById('container4');
      const container5 = document.getElementById('container5');

      if (!SHOW_CONTAINER_2) {
        container2.style.display = 'none';
      }
      if (!SHOW_CONTAINER_3) {
        container3.style.display = 'none';
      }
      if (!SHOW_CONTAINER_4) {
        container4.style.display = 'none';
      }
      if (!SHOW_CONTAINER_5) {
        container5.style.display = 'none';
      }

      const row2Visible = SHOW_CONTAINER_5;
      const row3Visible = SHOW_CONTAINER_2;
      const row4Visible = SHOW_CONTAINER_3 || SHOW_CONTAINER_4;

      let gridRows = [];
      let currentRow = 1;

      const container1Height = 20 - (row2Visible ? 1 : 0) - (row3Visible ? 2 : 0) - (row4Visible ? 1 : 0);
      gridRows.push(`${container1Height}fr`);

      if (row2Visible) {
        gridRows.push('1fr');
        currentRow++;
        container5.style.gridRow = currentRow.toString();
      }

      if (row3Visible) {
        gridRows.push('2fr');
        currentRow++;
        container2.style.gridRow = currentRow.toString();
      }

      if (row4Visible) {
        gridRows.push('1fr');
        currentRow++;
        if (SHOW_CONTAINER_3) container3.style.gridRow = currentRow.toString();
        if (SHOW_CONTAINER_4) container4.style.gridRow = currentRow.toString();
      }

      vizGrid.style.gridTemplateRows = gridRows.join(' ');
      container1.style.gridRow = '1';

      if (row4Visible) {
        if (SHOW_CONTAINER_3 && !SHOW_CONTAINER_4) {
          container3.style.gridColumn = '1 / span 2';
        } else if (!SHOW_CONTAINER_3 && SHOW_CONTAINER_4) {
          container4.style.gridColumn = '1 / span 2';
        }
      }
    })();

    const PLOT_TYPE = "bar";
    const originalData = [
  {
    "id": "image_captioning",
    "value": 0.104812591,
    "name": "image_captioning",
    "total_gpu_energy_std_dev": 0.053509306696586705,
    "energy_score_std_dev": 1.66332999331662
  },
  {
    "id": "asr",
    "value": 0.022105631076923073,
    "name": "asr",
    "total_gpu_energy_std_dev": 0.025164234058411877,
    "energy_score_std_dev": 1.3155870289605436
  },
  {
    "id": "image_generation",
    "value": 0.51903984475,
    "name": "image_generation",
    "total_gpu_energy_std_dev": 0.4609422029255077,
    "energy_score_std_dev": 1.3371158468430429
  },
  {
    "id": "sentence_similarity",
    "value": 0.0012644003157894735,
    "name": "sentence_similarity",
    "total_gpu_energy_std_dev": 0.001714284365546194,
    "energy_score_std_dev": 1.521771820505364
  },
  {
    "id": "text_generation",
    "value": 0.25387467258064517,
    "name": "text_generation",
    "total_gpu_energy_std_dev": 0.6278160094645073,
    "energy_score_std_dev": 1.4721098296690178
  },
  {
    "id": "text_classification",
    "value": 0.004387075076923077,
    "name": "text_classification",
    "total_gpu_energy_std_dev": 0.007878947364807787,
    "energy_score_std_dev": 1.198289379030556
  },
  {
    "id": "image_classification",
    "value": 0.0010079482173913042,
    "name": "image_classification",
    "total_gpu_energy_std_dev": 0.0006314352999419048,
    "energy_score_std_dev": 1.2399795994751786
  },
  {
    "id": "summarization",
    "value": 0.006944257090909092,
    "name": "summarization",
    "total_gpu_energy_std_dev": 0.00996784142110908,
    "energy_score_std_dev": 1.2135597524338357
  },
  {
    "id": "object_detection",
    "value": 0.003358950857142857,
    "name": "object_detection",
    "total_gpu_energy_std_dev": 0.0022016739227240585,
    "energy_score_std_dev": 1.3451854182690985
  },
  {
    "id": "question_answering",
    "value": 0.02254718355555556,
    "name": "question_answering",
    "total_gpu_energy_std_dev": 0.04673302322792158,
    "energy_score_std_dev": 1.0966377611066325
  },
  {
    "id": "reasoning",
    "value": 6.1469572222222215,
    "name": "reasoning",
    "total_gpu_energy_std_dev": 5.277647210792509,
    "energy_score_std_dev": 1.7452081921613043
  }
];
    const TREEMAP_BORDER_RADIUS = 6;
    const TREEMAP_SHOW_VALUES = 0;
    const BAR_BORDER_RADIUS = 0;
    const BAR_USE_GRADIENT = 1;
    const BAR_VALUE_POSITION = "outside";
    const BAR_ORIENTATION = "horizontal";
    const BAR_COLOR_BY_GROUP = 0;
    const PALETTE_MODE = "aiw";

    function normalizeData(arr) {
      return arr.map(function (d) {
        var parent = d.parent || d.group || d.domain || d.category || d.type || d.class;
        var name = d.name || d.id || d.label || d.title;
        var value = (d.value != null) ? +d.value : (d.count != null) ? +d.count : (d.size != null) ? +d.size : 0;
        var color = d.color != null ? d.color : null;
        return { parent: parent, name: name, value: value, color: color };
      });
    }

    let treemapData = normalizeData(originalData);
    const groups = Array.from(new Set(treemapData.map(function (d) { return d.parent; })));
    const inferredColors = {};
    groups.forEach(function (g) {
      var item = originalData.find(function (x) {
        var p = x.parent || x.group || x.domain || x.category || x.type || x.class;
        return p === g;
      });
      inferredColors[g] = item && item.color ? item.color : null;
    });

    const fallbackPalette = ["#1F77B4", "#FF7F0E", "#2CA02C", "#9467BD", "#D62728", "#17BECF", "#8C564B", "#E377C2", "#7F7F7F", "#BCBD22"];
    const groupColors = {};
    groups.forEach(function (g, i) {
      var baseColor;
      if (inferredColors[g]) baseColor = inferredColors[g];
      else if (PALETTE_MODE === "aiw") baseColor = "#2756d3";
      else if (PALETTE_MODE === "ceps") baseColor = "#207164";
      else baseColor = fallbackPalette[i % fallbackPalette.length];
      groupColors[g] = baseColor;
    });

    const activeGroups = new Set(groups);

    function getGroupColor(parent) {
      var c = groupColors[parent];
      if (!c && (PALETTE_MODE === "aiw" || PALETTE_MODE === "ceps")) {
        return PALETTE_MODE === "aiw" ? "#2756d3" : "#207164";
      }
      return c || "#666666";
    }

    let legendInitialized = false;

    function getLegendElement() {
      var legend = document.getElementById("legend");
      if (legend) return legend;
      var legendContainer = document.getElementById("container2");
      if (!legendContainer) return null;
      legend = document.createElement("div");
      legend.id = "legend";
      legend.className = "custom-legend";
      legendContainer.appendChild(legend);
      return legend;
    }

    function buildLegend() {
      if (legendInitialized) return;
      var legend = getLegendElement();
      if (!legend) return;
      legend.innerHTML = "";
      groups.forEach(function (g) {
        var item = document.createElement("div");
        item.className = "legend-item active";
        item.setAttribute("data-group", g);
        item.setAttribute("role", "button");
        item.setAttribute("tabindex", "0");
        item.setAttribute("aria-pressed", "true");

        var square = document.createElement("div");
        square.className = "legend-square";
        square.style.backgroundColor = getGroupColor(g);
        square.style.borderRadius = TREEMAP_BORDER_RADIUS + "px";

        var label = document.createElement("span");
        label.textContent = g;

        item.appendChild(square);
        item.appendChild(label);

        var toggleGroup = function () {
          if (activeGroups.has(g)) {
            activeGroups.delete(g);
          } else {
            activeGroups.add(g);
          }
          updateVisualization();
        };

        item.addEventListener("click", toggleGroup);
        item.addEventListener("keydown", function (e) {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            toggleGroup();
          }
        });

        legend.appendChild(item);
      });
      legendInitialized = true;
    }

    function updateLegendStyles() {
      var legend = document.getElementById("legend");
      if (!legend) return;
      var items = legend.querySelectorAll(".legend-item");
      items.forEach(function (item) {
        var grp = item.getAttribute("data-group");
        var isActive = activeGroups.has(grp);
        item.classList.toggle("inactive", !isActive);
        item.classList.toggle("active", isActive);
        item.setAttribute("aria-pressed", isActive ? "true" : "false");
      });
    }

    let treemapInstance = null;
    let barSvg = null;
    let barTooltip = null;
    let barRevealTimeout = null;

    function ensureTreemapInstance(width, height) {
      if (!vizContainer) return null;
      if (!treemapInstance) {
        treemapInstance = new d3plus.Treemap()
          .select("#" + VIZ_CONTAINER_ID)
          .data(treemapData)
          .groupBy(["parent", "name"])
          .tooltipConfig({
            title: function (d) { return d.name; },
            body: function (d) {
              var sector = d.parent || d.id;
              var count = d.value || 0;
              return "<strong>Sector:</strong> " + sector + "<br><strong>Count:</strong> " + count;
            }
          })
          .sum("value")
          .layoutPadding(2)
          .legend(false)
          .color(function (d) {
            return getGroupColor(d.parent || d.id);
          })
          .shapeConfig({
            rx: TREEMAP_BORDER_RADIUS,
            ry: TREEMAP_BORDER_RADIUS,
            stroke: function (d) {
              if (d.depth === 0) return getGroupColor(d.id);
              return "transparent";
            },
            strokeWidth: function (d) {
              if (d.depth === 0) return 3;
              return 0;
            }
          })
          .config({
            label: function (d) {
              if (!TREEMAP_SHOW_VALUES) return d.name;
              var value = (d && typeof d.value === "number") ? d.value : (d && d.value != null ? +d.value : 0);
              return d.name + " (" + value + ")";
            }
          });
      }

      if (typeof treemapInstance.width === "function" && width) {
        treemapInstance.width(width);
      }
      if (typeof treemapInstance.height === "function" && height) {
        treemapInstance.height(height);
      }

      return treemapInstance;
    }

    function renderBarChart(width, height) {
      if (!vizContainer) return;

      if (barRevealTimeout) {
        clearTimeout(barRevealTimeout);
        barRevealTimeout = null;
      }

      while (vizContainer.firstChild) {
        vizContainer.removeChild(vizContainer.firstChild);
      }

      if (!Array.isArray(treemapData) || treemapData.length === 0) {
        const empty = document.createElement("div");
        empty.style.display = "flex";
        empty.style.alignItems = "center";
        empty.style.justifyContent = "center";
        empty.style.height = "100%";
        empty.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, sans-serif";
        empty.style.color = "#666";
        empty.textContent = "No data available";
        vizContainer.appendChild(empty);
        barSvg = null;
        return;
      }

      const isVertical = BAR_ORIENTATION === "vertical";

      const margin = isVertical
        ? {
          top: 16,
          right: Math.max(40, width * 0.06),
          bottom: Math.max(36, height * 0.16),
          left: Math.max(40, width * 0.06)
        }
        : {
          top: 16,
          right: Math.max(40, width * 0.08),
          bottom: 28,
          left: Math.max(80, width * 0.22)
        };

      const innerWidth = Math.max(40, width - margin.left - margin.right);
      const innerHeight = Math.max(40, height - margin.top - margin.bottom);

      const svg = d3.select(vizContainer)
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", "0 0 " + width + " " + height)
        .style("width", "100%")
        .style("height", "100%");

      barSvg = svg;

      const g = svg.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      var data = treemapData.slice();

      var groupedByName = {};
      data.forEach(function (d) {
        var key = d.name || "";
        if (!key) return;
        if (!groupedByName[key]) {
          groupedByName[key] = {
            name: d.name,
            parent: d.parent,
            value: (typeof d.value === "number" ? d.value : +d.value || 0),
            color: d.color
          };
        }
      });

      data = Object.keys(groupedByName).map(function (k) { return groupedByName[k]; });

      const getNumericValue = function (d) {
        return (typeof d.value === "number" ? d.value : +d.value || 0);
      };

      data.sort(function (a, b) {
        return d3.descending(getNumericValue(a), getNumericValue(b));
      });

      const animationOrder = data.slice().sort(function (a, b) {
        return d3.ascending(getNumericValue(a), getNumericValue(b));
      });

      const finalBarName = animationOrder.length ? animationOrder[animationOrder.length - 1].name : null;
      const penultimateBarName = animationOrder.length > 1 ? animationOrder[animationOrder.length - 2].name : null;

      let x, y;

      if (isVertical) {
        x = d3.scaleBand()
          .domain([])
          .rangeRound([0, innerWidth])
          .paddingInner(0.2)
          .paddingOuter(0.4);

        y = d3.scaleLinear()
          .domain([0, 1])
          .nice()
          .range([innerHeight, 0]);
      } else {
        y = d3.scaleBand()
          .domain([])
          .rangeRound([0, innerHeight])
          .paddingInner(0.12)
          .paddingOuter(0.45);

        x = d3.scaleLinear()
          .domain([0, 1])
          .nice()
          .range([0, innerWidth]);
      }

      const backgroundGroup = g.append("g")
        .attr("class", "bar-backgrounds")
        .attr("fill", "none");

      const yAxisGroup = g.append("g")
        .attr("class", "axis axis--y");

      const xAxisGroup = g.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + innerHeight + ")");

      let xAxisLabel = null;
      const xAxisLabelPadding = 8;
      if (!isVertical) {
        xAxisLabel = g.append("text")
          .attr("class", "axis-label")
          .attr("x", innerWidth / 2)
          .attr("y", innerHeight + margin.bottom - 4 + xAxisLabelPadding)
          .attr("text-anchor", "middle")
          .style("font-weight", "600")
          .style("font-family", "system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, sans-serif")
          .style("fill", "#111827")
          .text("Wh per 1k Queries");
      }

      const defs = svg.append("defs");
      const grad = defs.append("linearGradient")
        .attr("id", "barGradient")
        .attr("gradientUnits", "objectBoundingBox");

      if (isVertical) {
        grad.attr("x1", "0%")
          .attr("y1", "100%")
          .attr("x2", "0%")
          .attr("y2", "0%");
      } else {
        grad.attr("x1", "0%")
          .attr("y1", "0%")
          .attr("x2", "100%")
          .attr("y2", "0%");
      }

      grad.append("stop")
        .attr("offset", "0%")
        .attr("stop-color", "#cfe8ff");

      grad.append("stop")
        .attr("offset", "100%")
        .attr("stop-color", "#1f78ff");

      if (!barTooltip) {
        barTooltip = document.createElement("div");
        barTooltip.style.position = "fixed";
        barTooltip.style.pointerEvents = "none";
        barTooltip.style.zIndex = "9999";
        barTooltip.style.background = "white";
        barTooltip.style.borderRadius = "8px";
        barTooltip.style.boxShadow = "0 8px 18px rgba(15,23,42,0.22)";
        barTooltip.style.padding = "8px 10px";
        barTooltip.style.fontSize = "12px";
        barTooltip.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, sans-serif";
        barTooltip.style.color = "#111827";
        barTooltip.style.opacity = "0";
        barTooltip.style.transition = "opacity 0.12s ease-out, transform 0.12s ease-out";
        barTooltip.style.transform = "translateY(0)";
        document.body.appendChild(barTooltip);
      }

      const barGroup = g.append("g")
        .attr("class", "bars");

      const valueLabelGroup = g.append("g")
        .attr("class", "value-labels");

      const formatValue = d3.format(".3f");
      const axisFontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, sans-serif";

      const getBarFill = function (d) {
        if (d.color) return d.color;
        if (BAR_COLOR_BY_GROUP) {
          return getGroupColor(d.parent);
        }
        if (PALETTE_MODE === "aiw") return "#2756d3";
        if (PALETTE_MODE === "ceps") return "#207164";
        if (BAR_USE_GRADIENT) {
          return "url(#barGradient)";
        }
        return "#1f78ff";
      };

      const applyBarInteractivity = function (selection) {
        selection
          .on("mousemove", function (event, d) {
            if (!barTooltip) return;
            var name = d.name || "";
            var v = getNumericValue(d);
            barTooltip.innerHTML = "<strong>" + name + "</strong><br/>Value: " + formatValue(v);
            barTooltip.style.left = (event.clientX + 14) + "px";
            barTooltip.style.top = (event.clientY - 24) + "px";
            barTooltip.style.opacity = "1";
            barTooltip.style.transform = "translateY(-2px)";
          })
          .on("mouseleave", function () {
            if (!barTooltip) return;
            barTooltip.style.opacity = "0";
            barTooltip.style.transform = "translateY(0)";
          });
      };

      const renderFrame = function (currentData) {
        if (!currentData || !currentData.length) {
          y.domain([]);
          xAxisGroup.call(d3.axisBottom(x));
          yAxisGroup.call(d3.axisLeft(isVertical ? y : y));
          valueLabelGroup.selectAll("text.value-label").remove();
          barGroup.selectAll("rect.bar").remove();
          backgroundGroup.selectAll("rect").remove();
          return;
        }

        const sortedData = currentData.slice().sort(function (a, b) {
          return d3.descending(getNumericValue(a), getNumericValue(b));
        });

        const axisFont = Math.max(9, Math.min(13, innerHeight / Math.max(6, sortedData.length) * 0.6));

        const getAnimationDuration = function (d) {
          var durationBase = 350;
          var durationRange = 450;
          var ratio;
          if (isVertical) {
            var value = getNumericValue(d);
            var barHeight = Math.max(0, innerHeight - y(value));
            ratio = innerHeight ? barHeight / innerHeight : 0;
          } else {
            var widthPx = Math.max(0, x(getNumericValue(d)));
            ratio = innerWidth ? widthPx / innerWidth : 0;
          }
          ratio = Math.min(1, Math.max(0, ratio || 0));
          var duration = durationBase + ratio * durationRange;
          if (finalBarName && d && d.name === finalBarName) {
            return duration * 5;
          }
          if (penultimateBarName && d && d.name === penultimateBarName) {
            return duration * 1.8;
          }
          return duration;
        };

        if (isVertical) {
          const maxValue = d3.max(sortedData, getNumericValue) || 0;
          y.domain([0, maxValue * 1.05 || 1]).nice();
          const outerPadding = sortedData.length <= 1 ? 0.5 : Math.min(0.24, 1.1 / sortedData.length);
          const innerPadding = sortedData.length <= 1 ? 0.15 : 0.12;
          x.domain(sortedData.map(function (d) { return d.name; }))
            .paddingOuter(outerPadding)
            .paddingInner(innerPadding);
        } else {
          const maxValue = d3.max(sortedData, getNumericValue) || 0;
          x.domain([0, maxValue * 1.05 || 1]).nice();
          const outerPadding = sortedData.length <= 1 ? 0.5 : Math.min(0.25, 1.2 / sortedData.length);
          const innerPadding = sortedData.length <= 1 ? 0 : 0.12;
          y.domain(sortedData.map(function (d) { return d.name; }))
            .paddingOuter(outerPadding)
            .paddingInner(innerPadding);
        }

        const axisLeft = d3.axisLeft(isVertical ? y : y);
        yAxisGroup.transition()
          .duration(500)
          .call(axisLeft)
          .selectAll("text")
          .style("font-size", axisFont + "px")
          .style("font-family", axisFontFamily);

        const axisBottom = isVertical ? d3.axisBottom(x) : d3.axisBottom(x).ticks(4);
        xAxisGroup.transition()
          .duration(500)
          .call(axisBottom)
          .selectAll("text")
          .style("font-size", axisFont + "px")
          .style("font-family", axisFontFamily);

        if (!isVertical && xAxisLabel) {
          xAxisLabel.style("font-size", (axisFont + 2) + "px");
        }

        if (isVertical) {
          backgroundGroup.selectAll("rect.row-bg").remove();
          const colBackgrounds = backgroundGroup.selectAll("rect.col-bg")
            .data(sortedData, function (d) { return d.name; });

          colBackgrounds.exit()
            .transition()
            .duration(400)
            .attr("width", 0)
            .remove();

          const colEnter = colBackgrounds.enter()
            .append("rect")
            .attr("class", "col-bg")
            .attr("x", innerWidth / 2)
            .attr("y", 0)
            .attr("width", 0)
            .attr("height", innerHeight)
            .attr("fill", "#ffffff")
            .attr("pointer-events", "none");

          colEnter.merge(colBackgrounds)
            .transition()
            .duration(500)
            .attr("x", function (d) { return x(d.name); })
            .attr("width", x.bandwidth())
            .attr("fill", function (_d, i) { return i % 2 ? "#f5f5f5" : "#ffffff"; });
        } else {
          backgroundGroup.selectAll("rect.col-bg").remove();
          const rowBackgrounds = backgroundGroup.selectAll("rect.row-bg")
            .data(sortedData, function (d) { return d.name; });

          rowBackgrounds.exit()
            .transition()
            .duration(400)
            .attr("height", 0)
            .attr("opacity", 0)
            .remove();

          const rowEnter = rowBackgrounds.enter()
            .append("rect")
            .attr("class", "row-bg")
            .attr("x", -margin.left)
            .attr("y", innerHeight / 2)
            .attr("width", innerWidth + margin.left + margin.right)
            .attr("height", 0)
            .attr("fill", "#ffffff")
            .attr("pointer-events", "none");

          rowEnter.merge(rowBackgrounds)
            .transition()
            .duration(500)
            .attr("y", function (d) { return y(d.name); })
            .attr("height", y.bandwidth())
            .attr("fill", function (_d, i) { return i % 2 ? "#f5f5f5" : "#ffffff"; });
        }

        if (isVertical) {
          const barThickness = Math.max(10, x.bandwidth() * 0.6);
          const bars = barGroup.selectAll("rect.bar")
            .data(sortedData, function (d) { return d.name; });

          bars.exit()
            .transition()
            .duration(500)
            .attr("y", innerHeight)
            .attr("height", 0)
            .style("opacity", 0)
            .remove();

          const barsEnter = bars.enter()
            .append("rect")
            .attr("class", "bar")
            .attr("rx", BAR_BORDER_RADIUS)
            .attr("ry", BAR_BORDER_RADIUS)
            .attr("fill", getBarFill)
            .attr("opacity", 0.95)
            .attr("x", function (d) { return x(d.name) + (x.bandwidth() - barThickness) / 2; })
            .attr("width", barThickness)
            .attr("y", innerHeight)
            .attr("height", 0);

          const mergedBars = barsEnter.merge(bars)
            .attr("fill", getBarFill);

          applyBarInteractivity(mergedBars);

          mergedBars.transition()
            .duration(function (d) { return getAnimationDuration(d); })
            .attr("x", function (d) { return x(d.name) + (x.bandwidth() - barThickness) / 2; })
            .attr("width", barThickness)
            .attr("y", function (d) {
              return y(getNumericValue(d));
            })
            .attr("height", function (d) {
              var v = getNumericValue(d);
              return Math.max(4, innerHeight - y(v));
            });
        } else {
          const barThickness = Math.max(10, y.bandwidth() * 0.8);
          const yOffset = (y.bandwidth() - barThickness) / 2;
          const bars = barGroup.selectAll("rect.bar")
            .data(sortedData, function (d) { return d.name; });

          bars.exit()
            .transition()
            .duration(500)
            .attr("width", 0)
            .style("opacity", 0)
            .remove();

          const barsEnter = bars.enter()
            .append("rect")
            .attr("class", "bar")
            .attr("rx", BAR_BORDER_RADIUS)
            .attr("ry", BAR_BORDER_RADIUS)
            .attr("fill", getBarFill)
            .attr("opacity", 0.95)
            .attr("x", 0)
            .attr("y", function (d) { return y(d.name) + yOffset; })
            .attr("height", barThickness)
            .attr("width", 0);

          const mergedBars = barsEnter.merge(bars)
            .attr("fill", getBarFill);

          applyBarInteractivity(mergedBars);

          mergedBars.transition()
            .duration(function (d) { return getAnimationDuration(d); })
            .attr("y", function (d) { return y(d.name) + yOffset; })
            .attr("height", barThickness)
            .attr("width", function (d) { return x(getNumericValue(d)); });

          if (BAR_VALUE_POSITION === "none") {
            valueLabelGroup.selectAll("text.value-label").remove();
          } else {
            const labels = valueLabelGroup.selectAll("text.value-label")
              .data(sortedData, function (d) { return d.name; });

            labels.exit()
              .transition()
              .duration(400)
              .style("opacity", 0)
              .remove();

            const labelsEnter = labels.enter()
              .append("text")
              .attr("class", "value-label")
              .attr("x", 0)
              .attr("y", innerHeight / 2)
              .attr("fill", BAR_VALUE_POSITION === "inside" ? "#ffffff" : "#111827")
              .attr("text-anchor", BAR_VALUE_POSITION === "outside" ? "start" : "end")
              .style("font-weight", "600")
              .style("font-family", axisFontFamily)
              .style("opacity", 0);

            labelsEnter.merge(labels)
              .transition()
              .duration(600)
              .attr("x", function (d) {
                var base = x(getNumericValue(d));
                return BAR_VALUE_POSITION === "outside" ? base + 6 : base - 6;
              })
              .attr("y", function (d) {
                return y(d.name) + yOffset + barThickness / 2 + 4;
              })
              .attr("text-anchor", BAR_VALUE_POSITION === "outside" ? "start" : "end")
              .attr("fill", BAR_VALUE_POSITION === "inside" ? "#ffffff" : "#111827")
              .style("font-size", Math.max(9, axisFont) + "px")
              .text(function (d) {
                return formatValue(getNumericValue(d));
              })
              .style("opacity", 1);
          }
        }

        if (isVertical && BAR_VALUE_POSITION !== "none") {
          const labels = valueLabelGroup.selectAll("text.value-label")
            .data(sortedData, function (d) { return d.name; });

          labels.exit()
            .transition()
            .duration(400)
            .style("opacity", 0)
            .remove();

          const labelsEnter = labels.enter()
            .append("text")
            .attr("class", "value-label")
            .attr("x", function (d) { return x(d.name) + x.bandwidth() / 2; })
            .attr("y", innerHeight)
            .attr("text-anchor", "middle")
            .attr("fill", BAR_VALUE_POSITION === "inside" ? "#ffffff" : "#111827")
            .style("font-weight", "600")
            .style("font-family", axisFontFamily)
            .style("opacity", 0);

          labelsEnter.merge(labels)
            .transition()
            .duration(600)
            .attr("x", function (d) { return x(d.name) + x.bandwidth() / 2; })
            .attr("y", function (d) {
              var v = getNumericValue(d);
              var topY = y(v);
              var barH = Math.max(4, innerHeight - topY);
              if (BAR_VALUE_POSITION === "outside") return topY - 6;
              var maxOffset = 14;
              var offset = Math.min(maxOffset, barH / 2);
              return topY + offset;
            })
            .attr("text-anchor", "middle")
            .attr("fill", BAR_VALUE_POSITION === "inside" ? "#ffffff" : "#111827")
            .style("font-size", Math.max(9, axisFont) + "px")
            .text(function (d) {
              return formatValue(getNumericValue(d));
            })
            .style("opacity", 1);
        } else if (isVertical && BAR_VALUE_POSITION === "none") {
          valueLabelGroup.selectAll("text.value-label").remove();
        }
      };

      if (!animationOrder.length) {
        return;
      }

      const visibleData = [];
      let revealIndex = 0;
      const revealDelay = 1500;

      const revealNext = function () {
        barRevealTimeout = null;
        if (revealIndex >= animationOrder.length) return;
        visibleData.push(animationOrder[revealIndex]);
        revealIndex += 1;
        renderFrame(visibleData);
        if (revealIndex < animationOrder.length) {
          barRevealTimeout = setTimeout(revealNext, revealDelay);
        }
      };

      revealNext();
    }

    function updateVisualization(width, height) {
      treemapData = normalizeData(originalData).filter(function (d) {
        return activeGroups.has(d.parent);
      });

      if (PLOT_TYPE === "treemap") {
        var instance = ensureTreemapInstance(width, height);
        if (!instance) return;
        instance.data(treemapData).render();
      } else if (PLOT_TYPE === "bar") {
        renderBarChart(width, height);
      }

      updateLegendStyles();
    }

    const renderVisualization = function (currentData, width, height) {
      buildLegend();
      updateVisualization(width, height);
    };

    const renderVisualizationForContainer = function () {
      if (!vizContainer) {
        return
      }
      const rect = vizContainer.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      renderVisualization(null, width, height);
    };

    let resizeTimer;

    window.addEventListener('resize', function () {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(renderVisualizationForContainer, 120);
    });

    if (typeof ResizeObserver !== 'undefined' && vizContainer) {
      const resizeObserver = new ResizeObserver(function () {
        renderVisualizationForContainer();
      });
      resizeObserver.observe(vizContainer);
    }

    renderVisualizationForContainer();
  </script>
</body>

</html>
