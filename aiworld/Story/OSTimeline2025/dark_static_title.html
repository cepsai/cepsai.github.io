<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>AI Timeline 2025 (Dark Static)</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">

    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #121212;
            color: #e5e7eb;
            font-family: 'Lato', sans-serif;
        }

        .viz-grid {
            display: grid;
            grid-template-rows: 1fr auto;
            height: 100vh;
            width: 100vw;
            background: #121212;
        }

        #chart-container {
            grid-row: 1;
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .control-bar {
            grid-row: 2;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 32px;
            background: #121212;
            border-top: none;
            z-index: 10;
        }

        .right-controls {
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .emoji-logo {
            font-size: 24px;
        }

        .source-text {
            font-size: clamp(10px, 1.6vw, 16px);
            font-weight: 600;
            color: #d1d5db;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            font-style: normal;
        }

        .source-text a {
            color: #60a5fa;
            text-decoration: underline;
            cursor: pointer;
            font-style: normal;
        }

        #error-log {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            color: red;
            z-index: 9999;
            padding: 20px;
        }

        @media (max-width: 768px) {
            .feature-msg {
                font-size: 24px !important;
            }

            .source-text {
                font-size: 11px !important;
            }

            .control-bar {
                padding: 8px 16px;
            }
        }

        #chart-container {
            width: 100%;
            height: 100%;
            min-height: 300px;
        }
    </style>
</head>

<body>

    <div id="error-log"></div>

    <div class="viz-grid">
        <div id="chart-container">
            <svg id="timeline-svg"></svg>
        </div>

        <div class="control-bar">
            <div class="source-text">
                Source: <a href="https://aiworld.eu" target="_blank">AI World</a>
            </div>

            <div class="right-controls">
                <div class="logo-container">
                    <img src="hf-logo.svg" class="logo" alt="Hugging Face" style="height: 45px; width: auto;">
                    <span class="sep" style="color: #9ca3af;">Ã—</span>
                    <img src="logo.svg" class="logo" alt="AI World"
                        onerror="this.style.display='none'; this.previousElementSibling.style.display='none';">
                </div>
            </div>
        </div>
    </div>

    <script>
        try {
            const DATA = [
                { date: "2024-12-12", event: "Phi-4", org: "Microsoft", color: "#9ca3af", description: "Demonstrated efficient small language models could punch above their weight class", dx: -5, dy: -10 },
                { date: "2025-01-20", event: "DeepSeek R1", org: "DeepSeek", color: "#4f8aff", description: "Redefined what was possible for open models with breakthrough reasoning capabilities", dx: 0, dy: -10 },
                { date: "2025-03-12", event: "Gemma 3", org: "Google", color: "#4285F4", description: "Enabled strong performance for cheap and fast tasks, democratizing AI deployment", dx: 5, dy: 20 },
                { date: "2025-04-05", event: "Llama 4", org: "Meta", color: "#0866FF", description: "Advanced multimodal understanding and set new standards for open-weight foundation models", dx: 10, dy: 20 },
                { date: "2025-04-28", event: "Qwen3 family", org: "Alibaba", color: "#FF6A00", description: "Brought multilingual excellence and strong reasoning to the open source community", dx: -20, dy: -10 },
                { date: "2025-05-07", event: "Mistral Medium 3", org: "Mistral AI", color: "#ef4444", description: "Balanced efficiency and capability, proving European AI could compete globally", dx: 10, dy: 25 },
                { date: "2025-07-11", event: "Kimi K2", org: "Moonshot AI", color: "#a855f7", description: "Pioneered extended context windows for open models, enabling novel long-form applications", dx: 5, dy: 15 },
                { date: "2025-07-28", event: "GLM-4.5", org: "Zhipu", color: "#2dd4bf", description: "Advanced Chinese language understanding", dx: -30, dy: -15 },
                { date: "2025-08-05", event: "OpenAI GPT-OSS", org: "OpenAI", color: "#ffffff", description: "Showed OpenAI's renewed commitment to open source", dx: 25, dy: 20 },
                { date: "2025-09-02", event: "Apertus LLM", org: "Switzerland", color: "#f87171", description: "Open model specifically designed for transparent research and reproducibility", dx: 25, dy: 15 },
                { date: "2025-10-27", event: "MiniMax M2", org: "MiniMax", color: "#FF2D55", description: "Excellent agentic and coding performance", dx: -25, dy: -15 },
                { date: "2025-11-20", event: "Olmo 3", org: "AllenAI", color: "#f87171", description: "Fully transparent training process from data to weights, raising reproducibility standards", dx: 25, dy: 25 },
                { date: "2025-12-01", event: "DeepSeek V3.2", org: "DeepSeek", color: "#4f8aff", description: "Further optimized inference costs while maintaining frontier model performance", dx: -30, dy: -10 },
                { date: "2025-12-11", event: "Molmo 2", org: "AllenAI", color: "#f87171", description: "Advanced open multimodal understanding with fully documented training methodology", dx: 5, dy: 10 },
                { date: "2025-12-15", event: "Nemotron 3 Nano", org: "NVIDIA", color: "#76B900", description: "SOTA open agentic model", dx: -5, dy: -15 },
                { date: "2025-12-15", event: "Nemotron 3 Nano", org: "NVIDIA", color: "#76B900", description: "What a year!", dx: -5, dy: -15 },
                { date: "2025-12-15", event: "Nemotron 3 Nano", org: "NVIDIA", color: "#76B900", description: "2025 Timeline of major open source AI releases", dx: -5, dy: -15 },
            ];
            let state = { k: DATA.length, timer: null, isStraight: false }; // [STATIC] k initialized to full length
            const svg = d3.select("#timeline-svg");
            const container = document.getElementById("chart-container");

            function getPoint(t, width, height, margin, isStraight) {
                const x = margin.left + t * (width - margin.left - margin.right);
                if (isStraight) {
                    return { x, y: height / 2 + 50 };
                } else {
                    const k = 2.5;
                    const normalizedY = (Math.exp(k * t) - 1) / (Math.exp(k) - 1);
                    const y = (height - margin.bottom) - normalizedY * (height - margin.top - margin.bottom);
                    return { x, y };
                }
            }
            function render() {
                const rect = container.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;

                const isSmall = width < 700;
                const isTiny = width < 450;

                const margin = {
                    left: isSmall ? 40 : 100,
                    right: isSmall ? 60 : 120,
                    top: isSmall ? 100 : 140,
                    bottom: isSmall ? 60 : 80
                };

                const messageFontSize = Math.max(16, Math.min(width * 0.05, 34)) + "px";
                const labelFontSize = isSmall ? (isTiny ? "9px" : "11px") : "13px";
                const orgFontSize = isSmall ? (isTiny ? "7px" : "9px") : "11px";

                svg.attr("width", width).attr("height", height).selectAll("*").remove();

                const parseTime = d3.utcParse("%Y-%m-%d");
                const data = DATA.map(d => ({ ...d, dateObj: parseTime(d.date) })).sort((a, b) => a.dateObj - b.dateObj);
                const visibleData = data.slice(0, state.k);
                const timeScale = d3.scaleTime().domain(d3.extent(data, d => d.dateObj)).range([0, 1]);

                if (visibleData.length > 0) {
                    const pathData = [];
                    const lastT = timeScale(visibleData[visibleData.length - 1].dateObj);
                    for (let i = 0; i <= 80; i++) {
                        pathData.push(getPoint((i / 80) * lastT, width, height, margin, state.isStraight));
                    }
                    const lineGen = d3.line().x(d => d.x).y(d => d.y).curve(d3.curveBasis);
                    svg.append("path").attr("d", lineGen(pathData)).attr("stroke", "#ffffff").attr("stroke-width", 2.5).attr("fill", "none");
                }

                const startMonth = data[0].dateObj;
                const months = d3.utcMonth.range(startMonth, data[data.length - 1].dateObj, 1);
                const allowedMonths = ["Feb", "Apr", "Jun", "Aug", "Oct", "Nov", "Dec"];

                months.forEach(m => {
                    const mName = d3.utcFormat("%b")(m);
                    const year = m.getFullYear();

                    if (year === 2024 && mName === "Dec") return;
                    if (mName === "Jan") return;

                    if (!allowedMonths.includes(mName)) return;

                    const p = getPoint(timeScale(m), width, height, margin, state.isStraight);
                    svg.append("text")
                        .attr("x", p.x).attr("y", p.y + (isSmall ? 25 : 40))
                        .attr("text-anchor", "middle").attr("font-weight", "800")
                        .attr("fill", "#9ca3af")
                        .attr("font-size", isSmall ? "11px" : "14px").text(mName === "Jun" ? "June" : mName);
                });

                // Add 2025 Year Label at Jan 1st position (Dark Mode)
                const y2025 = parseTime("2025-01-01");
                if (y2025) {
                    const p = getPoint(timeScale(y2025), width, height, margin, state.isStraight);
                    svg.append("text")
                        .attr("x", p.x).attr("y", p.y + (isSmall ? 25 : 40))
                        .attr("text-anchor", "middle").attr("font-weight", "800")
                        .attr("fill", "#9ca3af")
                        .attr("font-size", isSmall ? "11px" : "14px").text("2025");
                }

                // Static Title
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", margin.top / 2)
                    .attr("text-anchor", "middle")
                    .attr("font-size", messageFontSize)
                    .attr("font-weight", "700")
                    .attr("fill", "#e5e7eb")
                    .text("2025 Timeline of major open source AI releases");

                visibleData.forEach((d, i) => {
                    const p = getPoint(timeScale(d.dateObj), width, height, margin, state.isStraight);
                    const isAlternate = i % 2 === 0;

                    const defaultDx = (isAlternate ? -1 : 1) * (isSmall ? 45 : 70);
                    const labelX = p.x + (d.dx !== undefined ? d.dx * (isSmall ? 1.5 : 3) : defaultDx);
                    const labelY = p.y + (d.dy !== undefined ? d.dy * (isSmall ? 1.5 : 3) : 0);
                    const anchor = labelX < p.x ? "end" : "start";

                    svg.append("line")
                        .attr("x1", p.x).attr("y1", p.y).attr("x2", labelX - (anchor === "end" ? -5 : 5)).attr("y2", labelY)
                        .attr("stroke", "#4b5563").attr("stroke-width", 1).attr("stroke-dasharray", "3,2");

                    const labelGroup = svg.append("g");
                    labelGroup.append("text")
                        .attr("x", labelX).attr("y", labelY)
                        .attr("text-anchor", anchor).attr("fill", d.color).attr("font-weight", "700")
                        .attr("font-size", labelFontSize).text(d.event);

                    if (d.org) {
                        labelGroup.append("text")
                            .attr("x", labelX).attr("y", labelY - (isSmall ? 10 : 14))
                            .attr("text-anchor", anchor).attr("fill", "#9ca3af").attr("font-weight", "500")
                            .attr("font-size", orgFontSize).text(d.org);
                    }

                    svg.append("circle")
                        .attr("cx", p.x).attr("cy", p.y).attr("r", isSmall ? 3.5 : 5)
                        .attr("fill", d.color).attr("stroke", "#1f2937").attr("stroke-width", 2);

                    // No description text since based on no_text
                });
            }

            // removed replayAnimation function and call

            window.addEventListener('resize', render);

            // Initial Render
            render();

            window.addEventListener('resize', () => {
                render();
            });

        } catch (e) {
            console.error(e);
            document.getElementById('error-log').style.display = 'block';
            document.getElementById('error-log').innerHTML = "Error: " + e.message;
        }
    </script>
</body>

</html>