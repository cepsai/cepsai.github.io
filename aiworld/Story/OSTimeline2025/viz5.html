<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Timeline 2025</title>
  
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">

  <style>
    html, body { 
      height: 100%; margin: 0; padding: 0; 
      overflow: hidden; background: #ffffff; 
      font-family: 'Lato', sans-serif;
    }
    
    .viz-grid { 
      display: grid; 
      grid-template-rows: 1fr auto; 
      height: 100vh; width: 100vw; 
      background: #ffffff;
    }
    
    #chart-container { 
      grid-row: 1; 
      position: relative; 
      width: 100%; height: 100%; 
      overflow: hidden; 
      min-height: 200px;
    }

    svg { width: 100%; height: 100%; display: block; }
    
    .control-bar { 
      grid-row: 2; 
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 20px; border-top: 1px solid #e5e7eb;
      background: #ffffff; min-height: 56px; z-index: 10;
    }

    .source-text { font-size: 13px; font-weight: 600; color: #333; }
    .source-text a { color: #2756d3; text-decoration: underline; }
    .btn-group { display: flex; gap: 10px; }
    .btn-pill { 
      padding: 6px 16px; border: 1px solid #d1d5db; border-radius: 8px; 
      background: #fff; font-weight: 700; color: #374151; cursor: pointer; font-size: 13px; 
      transition: all 0.2s; white-space: nowrap;
    }
    .btn-pill:hover { background: #f3f4f6; }
    .btn-active { background: #2563eb !important; color: #fff !important; border-color: #2563eb !important; }
    .logo-container { display: flex; align-items: center; gap: 8px; }
    .logo { height: 24px; width: auto; object-fit: contain; }
    .sep { color: #d1d5db; margin: 0 2px; }

    @media (max-width: 600px) {
      .source-text, .logo-container { display: none; }
      .btn-group { display: none; }
      .control-bar { justify-content: center; }
    }
    
    #error-log {
        display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(255,255,255,0.95); color: red; z-index: 9999; padding: 20px;
    }
  </style>
</head>
<body>

  <div id="error-log"></div>

  <div class="viz-grid">
    <div id="chart-container">
      <svg id="timeline-svg"></svg>
    </div>

    <div class="control-bar">
      <div class="source-text">Source: <a href="https://huggingface.co/" target="_blank">HuggingFace</a></div>
      <div class="btn-group">
        <button id="btnPlay" class="btn-pill btn-active">Play</button>
        <button id="btnReset" class="btn-pill">Reset</button>
        <button id="btnDownload" class="btn-pill">Download PNG</button>
      </div>
      <div class="logo-container">
        <img src="https://huggingface.co/front/assets/huggingface_logo-noborder.svg" class="logo" alt="HF">
        <span class="sep">Ã—</span>
        <img src="logo.svg" class="logo" alt="AI World">
      </div>
    </div>
  </div>

<script>
window.onerror = function(msg) {
    const el = document.getElementById('error-log');
    el.style.display = 'block'; el.innerHTML = "Error: " + msg;
};

try {
    if (typeof d3 === 'undefined') throw new Error("D3 not loaded.");

    const SETTINGS = { minimalThreshold: 550, revealSpeed: 500 };
    
    // Added 'priority' to more items to ensure key context remains in minimal mode
  
    const DATA = [
      { date: "2025-01-08", event: "Phi-4", org: "Microsoft", color: "#737373" },
      { date: "2025-01-20", event: "DeepSeek R1", org: "DeepSeek", color: "#003366", priority: true },
      { date: "2025-03-12", event: "Gemma 3", org: "Google", color: "#4285F4" },
      { date: "2025-04-05", event: "Llama 4", org: "Meta", color: "#0866FF", priority: true },
      { date: "2025-04-28", event: "Qwen3 family", org: "Alibaba", color: "#FF6A00" },
      { date: "2025-05-07", event: "Mistral Medium 3", org: "Mistral AI", color: "#E0002A" },
      { date: "2025-07-28", event: "GLM-4.5", org: "Zhipu", color: "#00A3A3" },
      { date: "2025-08-05", event: "OpenAI GPT-OSS", org: "OpenAI", color: "#000000", priority: true },
      { date: "2025-08-21", event: "DeepSeek V3.1", org: "DeepSeek", color: "#003366" },
      { date: "2025-09-02", event: "Apertus LLM", org: "Switzerland", color: "#D52B1E" },
      { date: "2025-1-07", event: "Kimi K2 Thinking", org: "Moonshot AI", color: "#6A1B9A" },
      { date: "2025-11-20", event: "Olmo3", org: "AllenAI", color: "#D52B1E" },
      { date: "2025-12-01", event: "DeepSeek V3.2", org: "DeepSeek", color: "#003366" },
      { date: "2025-12-11", event: "Molmo2", org: "AllenAI", color: "#D52B1E" },
      { date: "2025-12-15", event: "Nemotron 3", org: "NVIDIA", color: "#76B900", priority: true }
    ];

    let state = { k: DATA.length, timer: null, playing: false };
    const svg = d3.select("#timeline-svg");
    const container = document.getElementById("chart-container");

    function render() {
      // 1. Get Dimensions
      const rect = container.getBoundingClientRect();
      const width = rect.width > 0 ? rect.width : window.innerWidth;
      const height = rect.height > 0 ? rect.height : (window.innerHeight - 60);

      // 2. Settings based on Width
      const isMinimal = width < SETTINGS.minimalThreshold;
      
      // Dynamic Font Sizing: Scales between 9px and 12px based on width
      const fontSizeVal = Math.max(9, Math.min(12, width / 60)); 
      const fontSize = fontSizeVal + "px";
      const fontOrgSize = (fontSizeVal - 2) + "px";
      
      // Buffer required between labels (in pixels)
      const labelCollisionBuffer = isMinimal ? 40 : 85; 

      const margin = isMinimal 
        ? { left: 20, right: 20, top: 40, bottom: 40 }
        : { left: 60, right: 60, top: 100, bottom: 100 };

      svg.attr("width", width).attr("height", height).selectAll("*").remove();

      const parseTime = d3.utcParse("%Y-%m-%d");
      const data = DATA.map(d => ({ ...d, dateObj: parseTime(d.date) })).sort((a,b) => a.dateObj - b.dateObj);
      const visibleData = data.slice(0, state.k);

      const x = d3.scaleUtc()
        .domain(d3.extent(data, d => d.dateObj))
        .range([margin.left, width - margin.right]);

      // Draw Center Axis
      svg.append("line")
        .attr("x1", margin.left).attr("x2", width - margin.right)
        .attr("y1", height / 2).attr("y2", height / 2)
        .attr("stroke", "#e5e7eb").attr("stroke-width", 2);

      // --- SMART STAGGERING LOGIC ---
      // We track the X-coordinate of the last label placed in each "Tier".
      // Tier 0 = Shortest Tick, Tier 2 = Longest Tick.
      const tiersUp = [-999, -999, -999, -999]; 
      const tiersDown = [-999, -999, -999, -999];
      const tickHeights = [30, 70, 110, 150]; // Heights for each tier

      visibleData.forEach((d, i) => {
        const cx = x(d.dateObj);
        const isUp = i % 2 === 0;
        
        // Decide to show label?
        const showLabel = !isMinimal || d.priority;

        let chosenTier = 0;
        let tickLen = tickHeights[0];

        // If we are showing a label, we need to find a tier that isn't crowded
        if (showLabel) {
            const lanes = isUp ? tiersUp : tiersDown;
            
            // Find the first lane where this label won't overlap the previous one
            let foundLane = -1;
            for (let t = 0; t < lanes.length; t++) {
                if (cx - lanes[t] > labelCollisionBuffer) {
                    foundLane = t;
                    break;
                }
            }

            // If all lanes full, wrap around to lane 2 or 0 (fallback)
            chosenTier = foundLane === -1 ? 2 : foundLane;
            
            // Update the last position for this lane
            lanes[chosenTier] = cx;
            tickLen = tickHeights[chosenTier];
        }

        const y = isUp ? (height / 2) - tickLen : (height / 2) + tickLen;
        const dotY = height / 2;

        if (showLabel) {
            // Tick Line
            svg.append("line")
              .attr("x1", cx).attr("x2", cx)
              .attr("y1", dotY).attr("y2", y)
              .attr("stroke", "#d1d5db").attr("stroke-dasharray", "3,3");
              
            // Event Label
            svg.append("text")
              .attr("x", cx)
              .attr("y", isUp ? y - 10 : y + 18)
              .attr("text-anchor", "middle")
              .attr("fill", d.color)
              .attr("font-size", fontSize) // Dynamic Size
              .attr("font-weight", "700")
              .text(d.event);
            
            // Org Label (Only if not minimal to save extra vertical space)
            if (!isMinimal) {
                svg.append("text")
                  .attr("x", cx)
                  .attr("y", isUp ? y - 22 : y + 30)
                  .attr("text-anchor", "middle")
                  .attr("fill", "#9ca3af")
                  .attr("font-size", fontOrgSize) // Dynamic Size
                  .text(d.org);
            }
        }

        // Dot
        svg.append("circle")
          .attr("cx", cx).attr("cy", dotY)
          .attr("r", isMinimal ? 3 : 5) // Smaller dots on minimal
          .attr("fill", d.color).attr("stroke", "#ffffff").attr("stroke-width", 2);

        // Date on Axis (Only in full mode)
        if (!isMinimal) {
            svg.append("text")
              .attr("x", cx)
              .attr("y", isUp ? dotY + 15 : dotY - 7)
              .attr("text-anchor", "middle")
              .attr("font-size", "10px")
              .attr("fill", "#6b7280")
              .text(d3.utcFormat("%b %d")(d.dateObj));
        }
      });
    }

    // --- CONTROLS ---
    document.getElementById("btnPlay").onclick = function() {
      if(state.playing) {
        clearInterval(state.timer); state.playing = false;
        this.textContent = "Play"; this.classList.add("btn-active");
      } else {
        if(state.k >= DATA.length) state.k = 0;
        state.playing = true; this.textContent = "Pause"; this.classList.remove("btn-active");
        state.timer = setInterval(() => {
          if(state.k < DATA.length) { state.k++; render(); }
          else { clearInterval(state.timer); state.playing = false; this.textContent = "Play"; this.classList.add("btn-active"); }
        }, SETTINGS.revealSpeed);
      }
    };

    document.getElementById("btnReset").onclick = () => {
        state.k = 0; render();
        clearInterval(state.timer); state.playing = false;
        const btn = document.getElementById("btnPlay"); btn.textContent = "Play"; btn.classList.add("btn-active");
    };

    document.getElementById("btnDownload").onclick = () => {
        const svgEl = document.getElementById("timeline-svg");
        const serializer = new XMLSerializer();
        const source = serializer.serializeToString(svgEl);
        const canvas = document.createElement("canvas");
        const rect = svgEl.getBoundingClientRect();
        canvas.width = rect.width * 2; canvas.height = rect.height * 2;
        const ctx = canvas.getContext("2d");
        const img = new Image();
        img.onload = () => {
            ctx.fillStyle = "#ffffff"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.scale(2, 2); ctx.drawImage(img, 0, 0);
            const a = document.createElement("a");
            a.download = "timeline.png"; a.href = canvas.toDataURL("image/png"); a.click();
        };
        img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
    };

    const observer = new ResizeObserver(() => { render(); });
    observer.observe(container);

    render();

} catch (e) {
    document.getElementById('error-log').style.display = 'block';
    document.getElementById('error-log').innerHTML = "CRITICAL ERROR: " + e.message;
}
</script>
</body>
</html>